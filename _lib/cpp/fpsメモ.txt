参考資料
・考え方のまとめ(maspyさん)
https://maspypy.com/%E5%A4%9A%E9%A0%85%E5%BC%8F%E3%83%BB%E5%BD%A2%E5%BC%8F%E7%9A%84%E3%81%B9%E3%81%8D%E7%B4%9A%E6%95%B0%E6%95%B0%E3%81%88%E4%B8%8A%E3%81%92%E3%81%A8%E3%81%AE%E5%AF%BE%E5%BF%9C%E4%BB%98%E3%81%91
https://maspypy.com/%E5%A4%9A%E9%A0%85%E5%BC%8F%E3%83%BB%E5%BD%A2%E5%BC%8F%E7%9A%84%E3%81%B9%E3%81%8D%E7%B4%9A%E6%95%B0%EF%BC%88%EF%BC%92%EF%BC%89%E5%BC%8F%E5%A4%89%E5%BD%A2%E3%81%AB%E3%82%88%E3%82%8B%E8%A7%A3%E6%B3%95
・式変形とか一覧(hotmanさん)
https://qiita.com/hotman78/items/f0e6d2265badd84d429a
・問題集(optさん)
https://opt-cp.com/fps-problem-list/
・お気持ち理解のため最初に使ったはまやんさんのやつ
https://blog.hamayanhamayan.com/entry/2019/12/07/000441

(log,exp使う方の)powがちゃんと効かない
・多分、最終的に欲しい項まで(0でも)作っておくと大丈夫そう。log,expの使用条件もあるっぽい。
・繰り返し二乗法のやつのが遅いけど多分そっちはいつでも使える。

Σx^nが1/(1-x)になるのはなぜか
・形的に等比数列の和の公式から来てると思うんだけど、r^nがめちゃでかくなったらINFとかだと、
　-INF/(1-x)とかになるはずで話が合わない。と思ったら、どうやら極限がINFじゃなくて0みたいな話らしい。
　というのも、大きくなるほど隣の項とか周りの項との差が(みんなでかすぎて)ほぼ無になるので、
　そういう意味で0みたいな。(多分。そうなんだと解釈した。)

DP遷移をFPS数列に入れて、K回遷移をK回多項式乗算みたいにする方針
・多項式のK乗が線形logで出せるようで、3乗DPが線形logに落とせる場面もあった。
　がしかしこのlogが畳み込みのlogで重く、制約100万とかだと間に合わないようだ。
・結局式変形を駆使することで、2項のみの多項式にしたりで高速化して通した。

wolframalphaに式を投げると、級数表現っていうのが得られることがあって、これが高速化に繋がったりするっぽい。
