不等号と整数除算の対応
x > a/b  : x > floor(a, b) + 1
x >= a/b : x >= ceil(a, b)
x <= a/b : x <= floor(a, b)
x < a/b  : x < ceil(a, b) - 1

にぶたん境界のindex
x未満で最大：left-1
x以上で最小：left
x以下で最大：right-1
x超で最小：right
※ペアで後ろを適当にしたい時は、leftなら{x, -INF}, rightなら{x, INF}

にぶたん境界の個数
x未満の数：left
x以下の数：right
x以上の数：全体-left
x超の数：全体-right

不等号とEPSの対応
a < b  : a < b-EPS
a <= b : a < b+EPS ※ a <= b+EPS か a-EPS < b+EPS のがいいかも
floor(a) : floor(a+EPS)

ある配列の区間[l,r)の真ん中index
偶数長で小さい方にする
ceil(l+r, 2) - 1
偶数長で大きい方にする
(l+r) // 2

ループの終端
半分で奇数の真ん中を数える： ceil(N, 2)
半分で奇数の真ん中を数えない： floor(N, 2)

余りの反対みたいなんだけど割り切れたら0にするたまに出るあれ
(mod - N % mod) % mod
pythonだと↓これでもOK
-N % mod

足りるならある値、足りないならめいっぱいまで使うあれ
use = min(a // cur, cnt)
cnt -= use
a -= use * cur
use = min(a, b)
ans += use * 2
a -= use
b -= use
use = min(a-x, cnt)
a -= use
cnt -= use
※色々バリエーションあるのであくまでベースとして

C++の高速化に関する情報
https://qiita.com/ageprocpp/items/7bda728d109c953ece3c
https://codeforces.com/blog/entry/66279

累積和同時進行DPの実装
ABC183e,cf1452dを参考に。初期化は自明な場所を埋めるとして、基本は、
dp[今] += acc[DPにさせたい遷移]
acc[今] = dp[今] + acc[累積和にさせたい遷移]
みたいにすればよさそう。
なお、累積和の添字を1個ずらしてacc[0]を絶対0みたいにすれば、
セグ木とかの一般的な半開区間の取得と添字が合って分かりやすいかも。
この時、dp[N]とacc[N+1]が対応する感じ。

一番下のビットを取り出す
N & -N
多分BITの中とかで出てくるのこれだね。

MOD Kの累積和をバグらせないために
左端-1とかやめよう。左端-Kだよ。

あるビットを消したい時
bit &= ~(1<<i)
bit & ~(1<<i)

有向グラフの閉路検出は状態3つ！2つじゃダメだよ。

シグマの式変形
ABC194_cで考え方をまとめた。まず以下3点はやってみよう。
・項毎にシグマを分ける。
・そのシグマに関係のない項を外に出す。
・そのシグマに関係のない係数を外に出す。
・係数、冪乗の指数j-iとかも分けれるよ。
ΣΣAi*Bj = ΣA[i] * Bの区間和
ΣΣAi+Bj = ΣA[i]*内ループの区間長 + Bの区間和

ビット演算の式変形
(a | b) + (a & b) = a + b
(a | b) ^ (a & b) = a ^ b
(a ^ b) + 2(a & b) = a + b

LCMの式変形
lcm(a, b) = a * b / gcd(a, b)
lcm(a, b) = k * gcd(a, b)

MODの式変形
x mod y = x - y * floor(x, y)

冪乗の式変形
a^(b*c) = (a^b)^c

a/b = x ならxがaの約数であることが成り立つので、aの約数を全探索

合同式の性質
a ≡ b の時、 a^k ≡ b^k
(元が同じなら指数付けても同じ。特に片方が1だとそっちは何乗せても1だから、
他方の指数を好きにいじれるので、そこに変数を置いたりできる。)

燃やす埋める
参考：https://www.slideshare.net/shindannin/project-selection-problem
　　　https://ei1333.github.io/luzhiled/snippets/memo/project-selection.html
・始点、終点、項目に当たる頂点
・2択を表す辺
・最小カットに帰着させるために、利得を得るような問題では、項目毎に利得-損益みたいなコストにする。
　つまり、損する方はそっちを選んだ場合に他方を選ぶより損する量、得する方は0みたいになる。
　(元々損失を決めるならそのままでも良さそうだけど、上記の形でやっても合いそうなので、常にやる気持ちでいいかも。)
　最終的に得る最小カットは「最大利益から引かれる最小値」なので、
　答え = 全部の選択肢で良い方を取った時の損益の総和 - 最小カット となる。
・2択でどちらを選ぶか強制的に決まっている所は、選べない方にINFの辺を張る。
　(そっちを選んだら損失がINFだから選べない、みたいなイメージ)
・制限は「Aを選ぶならBも選ばないといけない」だったら、A→Bに向かってINFの辺を張る。
　一般に、Aを選んでBを選ばない時に追加でかかるコストの辺をA→Bに張る。
　上記はAを選んだらBを選ばないということができなくなるので、そうなる時をINFにする感じ。
・「Aを選ぶならBは選んではいけない」はそのままだと使えないので、片方反転させるなり工夫が必要。
　具体的には、A,B側どちらかの選択肢(のs,tに繋ぐ関係)を反転させておく。こうすると、
　「Aを選ぶならBも選ばないといけない」に帰着できるので、辺が張れる。

過半数を問う問題は乱択を疑ってみる

clamp動かない問題
コンパイルオプションに
-std=c++17
って付けたら動いた。

隣接スワップは転倒数
任意スワップは連結成分の要素数-1
をベースに考えてみる。

ツイッター検索
期間指定
since:2019-1-1
until:2019-10-31
人指定
from:username

2つの集合をマージする時の操作順序の通り数は、例えば{3つ},{5つ}だったら
その前の時点で各集合内での順序は決まっているはずなので、3!とか5!はしない。
それで、くっつけるに当たって3*5とかしないで、nCr(3+5, 3)とかにする。
3*5になるのは全ペア組ませる通り数だね。。

「○○ちょうど」は無理でも「○○以上」なら列挙できそうなら、包除を疑ってみる。

ソートしてDPの条件
A,Bの順とB,Aの順で置いた時の条件をそれぞれ式にしてみると、
どうすれば優劣がつけられるか分かるかも。

上位K個の列挙
参考：https://img.atcoder.jp/abc123/editorial.pdf
ここのD別解でやり方が書いてある。

平均値は総和0に

マンハッタン距離は縦横独立

N個の部屋にK人を入れる通り数
nHr(N, K) or nCr(N+K-1, K)
仕切りのやつ思い出せばいいんだけど、いつもNとKどっちがどっちか分からなくなるので。

todo: ライブラリ内のINFとか
#define INF INF と #ifndef とか組み合わせればいけるぽいんだけど、
なんかもっとうまいやり方ありそう。。
それか#define MAIN みたいのを定義しといてテンプレ読み込み時にそれで条件判定するか。。
→暫定で #define CONSTANTS を宣言した。

添字がバグりそうな時は
・自分が取り扱っているのが開区間か閉区間かを自覚する
・デバッグできるポイントがあったら、コード全体が書き上がってなくてもちょっと動かしてみる
・添字に具体的な値を入れてみて検査してみる
・逆に、具体的な値で最初例を出してみて添字を合わせる
(from 物理さん)

差分の列(参考：chefのLTIME105A/VISEMALL,abc155_f)
・要素はN-1個。でも実装上は前後に「差分に影響なし」の番兵を入れてN+1個としておくと楽かも。
　端で場合分けしなくてよくなるので。以下、その前提で話す。
・区間操作は元の列での0-indexedの[l,r)が、差分列での[l],[r]の2点操作になる。
・区間取得は元の列での0-indexedの[l,r)が、差分列での[l+1,r)になる(区間が1狭まる)。1点取得xもx+1。

累積和の列(参考：abc223_f)
・要素はN+1個。先頭に0が入ってる前提で話す。
・2点操作は元の列での0-indexedの[l],[r]が、累積和列での[l+1,r+1)の区間操作になる。
・区間取得は状況によって話変わりそうだが、この括弧列の問題で言えば、
　元の列での0-indexedの[l,r)が、累積和列での[l,r+1)になる(区間が1広がる)。
　(2.cppの実装上は[l,r)になっているが、これは[r]が最小値となるようなケースは
　そもそも左右端の一致チェックで弾けているからで、本来は[l,r+1)が正しいはず。)
