不等号と整数除算の対応
x > a/b  : x > floor(a, b) + 1
x >= a/b : x >= ceil(a, b)
x <= a/b : x <= floor(a, b)
x < a/b  : x < ceil(a, b) - 1

にぶたん境界のindex
x未満で最大：left-1
x以上で最小：left
x以下で最大：right-1
x超で最小：right

にぶたん境界の個数
x未満の数：left
x以下の数：right
x以上の数：全体-left
x超の数：全体-right

不等号とEPSの対応
a < b  : a < b-EPS
a <= b : a < b+EPS ※ a <= b+EPS か a-EPS < b+EPS のがいいかも
floor(a) : floor(a+EPS)

ある配列の区間[l,r)の真ん中index
偶数長で小さい方にする
ceil(l+r, 2) - 1
偶数長で大きい方にする
(l+r) // 2

ループの終端
半分で奇数の真ん中を数える： ceil(N, 2)
半分で奇数の真ん中を数えない： floor(N, 2)

余りの反対みたいなんだけど割り切れたら0にするたまに出るあれ
(mod - N % mod) % mod
pythonだと↓これでもOK
-N % mod

足りるならある値、足りないならめいっぱいまで使うあれ
use = min(a // cur, cnt)
cnt -= use
a -= use * cur
use = min(a, b)
ans += use * 2
a -= use
b -= use
use = min(a-x, cnt)
a -= use
cnt -= use
※色々バリエーションあるのであくまでベースとして

C++の高速化に関する情報
https://qiita.com/ageprocpp/items/7bda728d109c953ece3c
https://codeforces.com/blog/entry/66279

累積和同時進行DPの実装
ABC183e,cf1452dを参考に。初期化は自明な場所を埋めるとして、基本は、
dp[今] += acc[DPにさせたい遷移]
acc[今] = dp[今] + acc[累積和にさせたい遷移]
みたいにすればよさそう。
なお、累積和の添字を1個ずらしてacc[0]を絶対0みたいにすれば、
セグ木とかの一般的な半開区間の取得と添字が合って分かりやすいかも。
この時、dp[N]とacc[N+1]が対応する感じ。

一番下のビットを取り出す
N & -N
多分BITの中とかで出てくるのこれだね。

MOD Kの累積和をバグらせないために
左端-1とかやめよう。左端-Kだよ。

あるビットを消したい時
bit &= ~(1<<i)
bit & ~(1<<i)

有向グラフの閉路検出は状態3つ！2つじゃダメだよ。

シグマの式変形
ABC194_cで考え方をまとめた。まず以下3点はやってみよう。
・項毎にシグマを分ける。
・そのシグマに関係のない項を外に出す。
・そのシグマに関係のない係数を外に出す。
・係数、冪乗の指数j-iとかも分けれるよ。
ΣΣAi*Bj = ΣA[i] * Bの区間和
ΣΣAi+Bj = ΣA[i]*内ループの区間長 + Bの区間和

ビット演算の式変形
(a | b) + (a & b) = a + b
(a | b) ^ (a & b) = a ^ b

LCMの式変形
lcm(a, b) = a * b / gcd(a, b)
lcm(a, b) = k * gcd(a, b)

MODの式変形
x mod y = x - y * floor(x, y)

冪乗の式変形
a^(b*c) = (a^b)^c

合同式の性質
a ≡ b の時、 a^k ≡ b^k
(元が同じなら指数付けても同じ。特に片方が1だとそっちは何乗せても1だから、
他方の指数を好きにいじれるので、そこに変数を置いたりできる。)

燃やす埋める
・始点、終点、項目に当たる頂点
・2択を表す辺
・最小カットに帰着させるので、項目毎に最大利得-損益みたいなコストにする。
　(診断人さんのスライドも参照)
・制限の辺は「Aを選ぶならBも選ばないといけない」だったら、A→Bに向かって張る。
・「Aを選ぶならBは選んではいけない」はそのままだと使えないので、
　片方反転させるなり工夫が必要。

過半数を問う問題は乱択を疑ってみる

clamp動かない問題
コンパイルオプションに
-std=c++17
って付けたら動いた。

隣接スワップは転倒数
任意スワップは連結成分の要素数-1
をベースに考えてみる。

ツイッター検索
期間指定
since:2019-1-1
until:2019-10-31
人指定
from:username

2つの集合をマージする時の操作順序の通り数は、例えば{3つ},{5つ}だったら
その前の時点で各集合内での順序は決まっているはずなので、3!とか5!はしない。
それで、くっつけるに当たって3*5とかしないで、nCr(3+5, 3)とかにする。
3*5になるのは全ペア組ませる通り数だね。。

「○○ちょうど」は無理でも「○○以上」なら列挙できそうなら、包除を疑ってみる。

ソートしてDPの条件
A,Bの順とB,Aの順で置いた時の条件をそれぞれ式にしてみると、
どうすれば優劣がつけられるか分かるかも。

上位K個の列挙
参考：https://img.atcoder.jp/abc123/editorial.pdf
ここのD別解でやり方が書いてある。
