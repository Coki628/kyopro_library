---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/base.hpp
    title: src/base.hpp
  - icon: ':warning:'
    path: src/combinatorics/ModTools.hpp
    title: src/combinatorics/ModTools.hpp
  - icon: ':warning:'
    path: src/combinatorics/combinations.hpp
    title: src/combinatorics/combinations.hpp
  - icon: ':warning:'
    path: src/combinatorics/nC2.hpp
    title: src/combinatorics/nC2.hpp
  - icon: ':warning:'
    path: src/combinatorics/permutations.hpp
    title: src/combinatorics/permutations.hpp
  - icon: ':warning:'
    path: src/common/Compress.hpp
    title: src/common/Compress.hpp
  - icon: ':warning:'
    path: src/common/Counter.hpp
    title: src/common/Counter.hpp
  - icon: ':warning:'
    path: src/common/HashMap.hpp
    title: src/common/HashMap.hpp
  - icon: ':warning:'
    path: src/common/HashMapImpl.hpp
    title: src/common/HashMapImpl.hpp
  - icon: ':warning:'
    path: src/common/RLE.hpp
    title: src/common/RLE.hpp
  - icon: ':warning:'
    path: src/common/bisearch.hpp
    title: src/common/bisearch.hpp
  - icon: ':x:'
    path: src/common/bisect.hpp
    title: src/common/bisect.hpp
  - icon: ':warning:'
    path: src/common/bit_length.hpp
    title: src/common/bit_length.hpp
  - icon: ':warning:'
    path: src/common/ceil.hpp
    title: src/common/ceil.hpp
  - icon: ':warning:'
    path: src/common/chmax.hpp
    title: src/common/chmax.hpp
  - icon: ':heavy_check_mark:'
    path: src/common/chmin.hpp
    title: src/common/chmin.hpp
  - icon: ':warning:'
    path: src/common/concat.hpp
    title: src/common/concat.hpp
  - icon: ':warning:'
    path: src/common/divmod.hpp
    title: src/common/divmod.hpp
  - icon: ':x:'
    path: src/common/input.hpp
    title: src/common/input.hpp
  - icon: ':warning:'
    path: src/common/join.hpp
    title: src/common/join.hpp
  - icon: ':x:'
    path: src/common/listnd.hpp
    title: src/common/listnd.hpp
  - icon: ':warning:'
    path: src/common/max.hpp
    title: src/common/max.hpp
  - icon: ':warning:'
    path: src/common/min.hpp
    title: src/common/min.hpp
  - icon: ':warning:'
    path: src/common/modulo.hpp
    title: src/common/modulo.hpp
  - icon: ':warning:'
    path: src/common/overflow.hpp
    title: src/common/overflow.hpp
  - icon: ':warning:'
    path: src/common/pair.hpp
    title: src/common/pair.hpp
  - icon: ':warning:'
    path: src/common/popcount.hpp
    title: src/common/popcount.hpp
  - icon: ':warning:'
    path: src/common/pow.hpp
    title: src/common/pow.hpp
  - icon: ':question:'
    path: src/common/print.hpp
    title: src/common/print.hpp
  - icon: ':warning:'
    path: src/common/reversed.hpp
    title: src/common/reversed.hpp
  - icon: ':warning:'
    path: src/common/sorted.hpp
    title: src/common/sorted.hpp
  - icon: ':warning:'
    path: src/common/split.hpp
    title: src/common/split.hpp
  - icon: ':warning:'
    path: src/common/subarray.hpp
    title: src/common/subarray.hpp
  - icon: ':x:'
    path: src/common/sum.hpp
    title: src/common/sum.hpp
  - icon: ':warning:'
    path: src/common/to_string.hpp
    title: src/common/to_string.hpp
  - icon: ':warning:'
    path: src/common/tochar.hpp
    title: src/common/tochar.hpp
  - icon: ':warning:'
    path: src/common/toint.hpp
    title: src/common/toint.hpp
  - icon: ':warning:'
    path: src/common/vector.hpp
    title: src/common/vector.hpp
  - icon: ':warning:'
    path: src/common/yesno.hpp
    title: src/common/yesno.hpp
  - icon: ':warning:'
    path: src/common/zip.hpp
    title: src/common/zip.hpp
  - icon: ':warning:'
    path: src/datastructure/Accumulate.hpp
    title: src/datastructure/Accumulate.hpp
  - icon: ':warning:'
    path: src/datastructure/BIT.hpp
    title: src/datastructure/BIT.hpp
  - icon: ':warning:'
    path: src/datastructure/SegmentTree.hpp
    title: src/datastructure/SegmentTree.hpp
  - icon: ':heavy_check_mark:'
    path: src/graph/UnionFind.hpp
    title: src/graph/UnionFind.hpp
  - icon: ':warning:'
    path: src/grid/constants/dir4.hpp
    title: src/grid/constants/dir4.hpp
  - icon: ':warning:'
    path: src/grid/constants/directions.hpp
    title: src/grid/constants/directions.hpp
  - icon: ':warning:'
    path: src/grid/gridtoid.hpp
    title: src/grid/gridtoid.hpp
  - icon: ':warning:'
    path: src/grid/idtogrid.hpp
    title: src/grid/idtogrid.hpp
  - icon: ':question:'
    path: src/macros.hpp
    title: src/macros.hpp
  - icon: ':warning:'
    path: src/mystl/Deque.hpp
    title: src/mystl/Deque.hpp
  - icon: ':warning:'
    path: src/mystl/Multiset.hpp
    title: src/mystl/Multiset.hpp
  - icon: ':warning:'
    path: src/mystl/PriorityQueue.hpp
    title: src/mystl/PriorityQueue.hpp
  - icon: ':warning:'
    path: src/mystl/Set.hpp
    title: src/mystl/Set.hpp
  - icon: ':warning:'
    path: src/mystl/Vector.hpp
    title: src/mystl/Vector.hpp
  - icon: ':warning:'
    path: src/mystl/defaultdict.hpp
    title: src/mystl/defaultdict.hpp
  - icon: ':warning:'
    path: src/numbers/divisors.hpp
    title: src/numbers/divisors.hpp
  - icon: ':warning:'
    path: src/numbers/factorize.hpp
    title: src/numbers/factorize.hpp
  - icon: ':warning:'
    path: src/numbers/gcd.hpp
    title: src/numbers/gcd.hpp
  - icon: ':warning:'
    path: src/numbers/lcm.hpp
    title: src/numbers/lcm.hpp
  - icon: ':warning:'
    path: src/string/bin.hpp
    title: src/string/bin.hpp
  - icon: ':warning:'
    path: src/string/zfill.hpp
    title: src/string/zfill.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':warning:'
  attributes:
    links: []
  bundledCode: "#line 2 \"src/base.hpp\"\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\
    using namespace std;\n#line 3 \"src/macros.hpp\"\n\nusing ll = long long;\nusing\
    \ ull = unsigned long long;\nusing ld = long double;\nusing pll = pair<ll, ll>;\n\
    using pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pil = pair<int,\
    \ ll>;\ntemplate<typename T>\nusing vv = vector<vector<T>>;\nusing vvl = vv<ll>;\n\
    using vvi = vv<int>;\nusing vvpll = vv<pll>;\nusing vvpli = vv<pli>;\nusing vvpil\
    \ = vv<pil>;\n#define name4(i, a, b, c, d, e, ...) e\n#define rep(...) name4(__VA_ARGS__,\
    \ rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rep1(i, a) for (ll i = 0, _aa\
    \ = a; i < _aa; i++)\n#define rep2(i, a, b) for (ll i = a, _bb = b; i < _bb; i++)\n\
    #define rep3(i, a, b, c) for (ll i = a, _bb = b; (c > 0 && a <= i && i < _bb)\
    \ or (c < 0 && a >= i && i > _bb); i += c)\n#define rrep(i, a, b) for (ll i=(a);\
    \ i>(b); i--)\n#define pb push_back\n#define eb emplace_back\n#define mkp make_pair\n\
    #define ALL(A) begin(A), end(A)\n#define UNIQUE(A) sort(ALL(A)), A.erase(unique(ALL(A)),\
    \ A.end())\n#define elif else if\n#define tostr to_string\n\n#ifndef CONSTANTS\n\
    \    constexpr ll INF = 1e18;\n    constexpr int MOD = 1000000007;\n    constexpr\
    \ ld EPS = 1e-10;\n    constexpr ld PI = M_PI;\n#endif\n#line 4 \"src/template.hpp\"\
    \n\n// from common\n#line 3 \"src/common/Compress.hpp\"\n\n// \u5EA7\u6A19\u5727\
    \u7E2E(\u4E8C\u5206\u63A2\u7D22\u30D9\u30FC\u30B9)\ntemplate<typename T>\nstruct\
    \ Compress {\n    int N;\n    vector<T> dat;\n    bool built = false;\n\n    Compress()\
    \ {}\n\n    Compress(const vector<T> &A) : dat(A) {\n        build();\n    }\n\
    \n    void build() {\n        sort(dat.begin(), dat.end());\n        dat.erase(unique(dat.begin(),\
    \ dat.end()), dat.end());\n        N = dat.size();\n        built = true;\n  \
    \  }\n\n    void add(T x) {\n        assert(not built);\n        dat.eb(x);\n\
    \    }\n\n    int zip(T x) {\n        assert(built);\n        return bisect_left(dat,\
    \ x);\n    }\n\n    T unzip(int x) {\n        assert(built);\n        return dat[x];\n\
    \    }\n\n    int operator[](T x) {\n        return zip(x);\n    }\n\n    int\
    \ size() {\n        assert(built);\n        return dat.size();\n    }\n\n    vector<ll>\
    \ zip(const vector<T> &A) {\n        int M = A.size();\n        vector<ll> res(M);\n\
    \        rep(i, M) res[i] = zip(A[i]);\n        return res;\n    }\n};\n\n// \u5EA7\
    \u6A19\u5727\u7E2E(map\u30D9\u30FC\u30B9)(\u65E7)\n// template<typename T>\n//\
    \ pair<map<T, int>, vector<T>> compress(vector<T> unzipped) {\n//     map<T, int>\
    \ zipped;\n//     sort(unzipped.begin(), unzipped.end());\n//     unzipped.erase(unique(unzipped.begin(),\
    \ unzipped.end()), unzipped.end());\n//     rep(i, unzipped.size()) {\n//    \
    \     zipped[unzipped[i]] = i;\n//     }\n//     return {zipped, unzipped};\n\
    // }\n#line 3 \"src/common/HashMapImpl.hpp\"\n\n// \u53C2\u8003\uFF1Ahttps://nyaannyaan.github.io/library/hashmap/hashmap-base.hpp\n\
    namespace HashMapImpl {\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\ntemplate<typename\
    \ Key, typename Data>\nstruct HashMapBase;\n\ntemplate<typename Key, typename\
    \ Data>\nstruct itrB\n    : iterator<bidirectional_iterator_tag, Data, ptrdiff_t,\
    \ Data *, Data &> {\n    using base =\n        iterator<bidirectional_iterator_tag,\
    \ Data, ptrdiff_t, Data *, Data &>;\n    using ptr = typename base::pointer;\n\
    \    using ref = typename base::reference;\n\n    u32 i;\n    HashMapBase<Key,\
    \ Data> *p;\n\n    explicit constexpr itrB() : i(0), p(nullptr) {\n    }\n   \
    \ explicit constexpr itrB(u32 _i, HashMapBase<Key, Data> *_p) : i(_i), p(_p) {\n\
    \    }\n    explicit constexpr itrB(u32 _i, const HashMapBase<Key, Data> *_p)\n\
    \        : i(_i),\n          p(const_cast<HashMapBase<Key, Data> *>(_p)) {\n \
    \   }\n    friend void swap(itrB &l, itrB &r) {\n        swap(l.i, r.i), swap(l.p,\
    \ r.p);\n    }\n    friend bool operator==(const itrB &l, const itrB &r) {\n \
    \       return l.i == r.i;\n    }\n    friend bool operator!=(const itrB &l, const\
    \ itrB &r) {\n        return l.i != r.i;\n    }\n    const ref operator*() const\
    \ {\n        return const_cast<const HashMapBase<Key, Data> *>(p)->data[i];\n\
    \    }\n    ref operator*() {\n        return p->data[i];\n    }\n    ptr operator->()\
    \ const {\n        return &(p->data[i]);\n    }\n\n    itrB &operator++() {\n\
    \        assert(i != p->cap && \"itr::operator++()\");\n        do {\n       \
    \     i++;\n            if (i == p->cap) break;\n            if (p->flag[i] ==\
    \ true && p->dflag[i] == false) break;\n        } while (true);\n        return\
    \ (*this);\n    }\n    itrB operator++(int) {\n        itrB it(*this);\n     \
    \   ++(*this);\n        return it;\n    }\n    itrB &operator--() {\n        do\
    \ {\n            i--;\n            if (p->flag[i] == true && p->dflag[i] == false)\
    \ break;\n            assert(i != 0 && \"itr::operator--()\");\n        } while\
    \ (true);\n        return (*this);\n    }\n    itrB operator--(int) {\n      \
    \  itrB it(*this);\n        --(*this);\n        return it;\n    }\n};\n\ntemplate<typename\
    \ Key, typename Data>\nstruct HashMapBase {\n    using u32 = uint32_t;\n    using\
    \ u64 = uint64_t;\n    using iterator = itrB<Key, Data>;\n    using itr = iterator;\n\
    \nprotected:\n    template<typename K>\n    inline u64 randomized(const K &key)\
    \ const {\n        return u64(key) ^ r;\n    }\n\n    template<\n        typename\
    \ K, enable_if_t<is_same<K, Key>::value, nullptr_t> = nullptr,\n        enable_if_t<is_integral<K>::value,\
    \ nullptr_t> = nullptr>\n    inline u32 inner_hash(const K &key) const {\n   \
    \     return (randomized(key) * 11995408973635179863ULL) >> shift;\n    }\n  \
    \  template<\n        typename K, enable_if_t<is_same<K, Key>::value, nullptr_t>\
    \ = nullptr,\n        enable_if_t<is_integral<decltype(K::first)>::value, nullptr_t>\
    \ =\n            nullptr,\n        enable_if_t<is_integral<decltype(K::second)>::value,\
    \ nullptr_t> =\n            nullptr>\n    inline u32 inner_hash(const K &key)\
    \ const {\n        u64 a = randomized(key.first), b = randomized(key.second);\n\
    \        a *= 11995408973635179863ULL;\n        b *= 10150724397891781847ULL;\n\
    \        return (a + b) >> shift;\n    }\n    template<\n        typename K, enable_if_t<is_same<K,\
    \ Key>::value, nullptr_t> = nullptr,\n        enable_if_t<is_integral<typename\
    \ K::value_type>::value, nullptr_t> =\n            nullptr>\n    inline u32 inner_hash(const\
    \ K &key) const {\n        static constexpr u64 mod = (1LL << 61) - 1;\n     \
    \   static constexpr u64 base = 950699498548472943ULL;\n        u64 res = 0;\n\
    \        for (auto &elem : key) {\n            __uint128_t x = __uint128_t(res)\
    \ * base + (randomized(elem) & mod);\n            res = (x & mod) + (x >> 61);\n\
    \        }\n        __uint128_t x = __uint128_t(res) * base;\n        res = (x\
    \ & mod) + (x >> 61);\n        if (res >= mod) res -= mod;\n        return res\
    \ >> (shift - 3);\n    }\n\n    template<\n        typename D = Data,\n      \
    \  enable_if_t<is_same<D, Key>::value, nullptr_t> = nullptr>\n    inline u32 hash(const\
    \ D &dat) const {\n        return inner_hash(dat);\n    }\n    template<\n   \
    \     typename D = Data,\n        enable_if_t<is_same<decltype(D::first), Key>::value,\
    \ nullptr_t> =\n            nullptr>\n    inline u32 hash(const D &dat) const\
    \ {\n        return inner_hash(dat.first);\n    }\n\n    template<\n        typename\
    \ D = Data,\n        enable_if_t<is_same<D, Key>::value, nullptr_t> = nullptr>\n\
    \    inline Key dtok(const D &dat) const {\n        return dat;\n    }\n    template<\n\
    \        typename D = Data,\n        enable_if_t<is_same<decltype(D::first), Key>::value,\
    \ nullptr_t> =\n            nullptr>\n    inline Key dtok(const D &dat) const\
    \ {\n        return dat.first;\n    }\n\n    void reallocate(u32 ncap) {\n   \
    \     vector<Data> ndata(ncap);\n        vector<bool> nf(ncap);\n        shift\
    \ = 64 - __lg(ncap);\n        for (u32 i = 0; i < cap; i++) {\n            if\
    \ (flag[i] == true && dflag[i] == false) {\n                u32 h = hash(data[i]);\n\
    \                while (nf[h]) h = (h + 1) & (ncap - 1);\n                ndata[h]\
    \ = move(data[i]);\n                nf[h] = true;\n            }\n        }\n\
    \        data.swap(ndata);\n        flag.swap(nf);\n        cap = ncap;\n    \
    \    dflag.resize(cap);\n        fill(std::begin(dflag), std::end(dflag), false);\n\
    \    }\n\n    inline bool extend_rate(u32 x) const {\n        return x * 2 >=\
    \ cap;\n    }\n\n    inline bool shrink_rate(u32 x) const {\n        return HASHMAP_DEFAULT_SIZE\
    \ < cap && x * 10 <= cap;\n    }\n\n    inline void extend() {\n        reallocate(cap\
    \ << 1);\n    }\n\n    inline void shrink() {\n        reallocate(cap >> 1);\n\
    \    }\n\npublic:\n    u32 cap, s;\n    vector<Data> data;\n    vector<bool> flag,\
    \ dflag;\n    u32 shift;\n    static u64 r;\n    static constexpr uint32_t HASHMAP_DEFAULT_SIZE\
    \ = 4;\n\n    explicit HashMapBase()\n        : cap(HASHMAP_DEFAULT_SIZE),\n \
    \         s(0),\n          data(cap),\n          flag(cap),\n          dflag(cap),\n\
    \          shift(64 - __lg(cap)) {\n    }\n\n    itr begin() const {\n       \
    \ u32 h = 0;\n        while (h != cap) {\n            if (flag[h] == true && dflag[h]\
    \ == false) break;\n            h++;\n        }\n        return itr(h, this);\n\
    \    }\n    itr end() const {\n        return itr(this->cap, this);\n    }\n\n\
    \    friend itr begin(const HashMapBase &h) {\n        return h.begin();\n   \
    \ }\n    friend itr end(const HashMapBase &h) {\n        return h.end();\n   \
    \ }\n\n    itr find(const Key &key) const {\n        u32 h = inner_hash(key);\n\
    \        while (true) {\n            if (flag[h] == false) return this->end();\n\
    \            if (dtok(data[h]) == key) {\n                if (dflag[h] == true)\
    \ return this->end();\n                return itr(h, this);\n            }\n \
    \           h = (h + 1) & (cap - 1);\n        }\n    }\n\n    bool contain(const\
    \ Key &key) const {\n        return find(key) != this->end();\n    }\n\n    itr\
    \ insert(const Data &d) {\n        u32 h = hash(d);\n        while (true) {\n\
    \            if (flag[h] == false) {\n                if (extend_rate(s + 1))\
    \ {\n                    extend();\n                    h = hash(d);\n       \
    \             continue;\n                }\n                data[h] = d;\n   \
    \             flag[h] = true;\n                ++s;\n                return itr(h,\
    \ this);\n            }\n            if (dtok(data[h]) == dtok(d)) {\n       \
    \         if (dflag[h] == true) {\n                    data[h] = d;\n        \
    \            dflag[h] = false;\n                    ++s;\n                }\n\
    \                return itr(h, this);\n            }\n            h = (h + 1)\
    \ & (cap - 1);\n        }\n    }\n\n    // tips for speed up :\n    // if return\
    \ value is unnecessary, make argument_2 false.\n    itr erase(itr it, bool get_next\
    \ = true) {\n        if (it == this->end()) return this->end();\n        s--;\n\
    \        if (shrink_rate(s)) {\n            Data d = data[it.i];\n           \
    \ shrink();\n            it = find(dtok(d));\n        }\n        int ni = (it.i\
    \ + 1) & (cap - 1);\n        if (this->flag[ni]) {\n            this->dflag[it.i]\
    \ = true;\n        } else {\n            this->flag[it.i] = false;\n        }\n\
    \        if (get_next) ++it;\n        return it;\n    }\n\n    itr erase(const\
    \ Key &key) {\n        return erase(find(key));\n    }\n\n    bool empty() const\
    \ {\n        return s == 0;\n    }\n\n    int size() const {\n        return s;\n\
    \    }\n\n    void clear() {\n        fill(std::begin(flag), std::end(flag), false);\n\
    \        fill(std::begin(dflag), std::end(dflag), false);\n        s = 0;\n  \
    \  }\n\n    void reserve(int n) {\n        if (n <= 0) return;\n        n = 1\
    \ << min(23, __lg(n) + 2);\n        if (cap < u32(n)) reallocate(n);\n    }\n\
    };\n\ntemplate<typename Key, typename Data>\nuint64_t HashMapBase<Key, Data>::r\
    \ =\n    chrono::duration_cast<chrono::nanoseconds>(\n        chrono::high_resolution_clock::now().time_since_epoch()\n\
    \    ).count();\n\n} // namespace HashMapImpl\n#line 4 \"src/common/HashMap.hpp\"\
    \n\n// \u53C2\u8003\uFF1Ahttps://nyaannyaan.github.io/library/hashmap/hashmap.hpp\n\
    // \u30FB\u3081\u3061\u3083\u901F\u3044\u3002\n// \u6CE8\u610F\u70B9\n// \u30FB\
    erase\u3057\u3066size\u53D6\u308B\u307F\u305F\u3044\u306A\u64CD\u4F5C\u3057\u3066\
    \u305F\u3089\u306A\u3093\u304B\u30ED\u30FC\u30AB\u30EB\u306F\u5927\u4E08\u592B\
    \u3060\u3051\u3069\n// \u3000\u30B3\u30FC\u30C9\u30C6\u30B9\u30C8\u3067\u6319\u52D5\
    \u304C\u4E00\u5B9A\u3067\u306A\u304F\u306A\u3063\u305F\u306E\u3067\u3001\u305D\
    \u308C\u3084\u308A\u305F\u3044\u6642\u306F\u5225\u5909\u6570\u3067size\u7BA1\u7406\
    \u3057\u305F\u65B9\u304C\u3044\u3044\u304B\u3082\u3002\n// \u30FB\u8272\u3005\u8A66\
    \u3057\u305F\u611F\u3058\u3001\u305D\u3082\u305D\u3082erase\u3084\u308B\u3053\u3068\
    \u304C\u975E\u63A8\u5968\u3068\u8003\u3048\u305F\u65B9\u304C\u826F\u3055\u305D\
    \u3046\u3002\n// \u30FBHashMap<int, mint>\u307F\u305F\u3044\u306E\u3067 += \u3084\
    \u308B\u6642\u306B\u3001\u8DB3\u3055\u308C\u308B\u5074\u306E\u6DFB\u5B57\u30A2\
    \u30AF\u30BB\u30B9\u3067extend\u304C\u8D70\u308B\u3068\u3001\n// \u3000\u8981\u7D20\
    \u306E\u4F4D\u7F6E\u304C\u5909\u308F\u3063\u3066\u3057\u307E\u3046\u305F\u3081\
    \u3001\u5148\u306B\u8A55\u4FA1\u3055\u308C\u3066\u65E2\u306B\u8FD4\u3057\u3066\
    \u3044\u308B\u8DB3\u3059\u5074\u306E\u53C2\u7167\u304C\u58CA\u308C\u308B\u3063\
    \u307D\u3044\u3002\n// \u3000\u306A\u3093\u304Bint\u3060\u3068\u5927\u4E08\u592B\
    \u3063\u307D\u3044\u306E\u3067\u3001mint\u307F\u305F\u3044\u306B\u30AA\u30D6\u30B8\
    \u30A7\u30AF\u30C8\u3060\u3068\u30C0\u30E1\u306A\u3093\u304B\u306A\u591A\u5206\
    \u3002\n// \u30FBDP\u306E2\u6B21\u5143\u76EE\u306B\u4F7F\u3063\u305F\u3089\u3001\
    \u30E1\u30E2\u30EA\u3092\u98DF\u3046\u3068\u7D50\u69CB\u91CD\u304F\u306A\u308B\
    \u3088\u3046\u3060\u3063\u305F\u306E\u3067\u3001\n// \u3000\u914D\u5217\u7BC0\u7D04\
    \u30C6\u30AF\u306F\u4F7F\u3063\u305F\u65B9\u304C\u826F\u3055\u3052\u3002\ntemplate<typename\
    \ Key, typename Val>\nstruct HashMap : HashMapImpl::HashMapBase<Key, pair<Key,\
    \ Val>> {\n    using base = typename HashMapImpl::HashMapBase<Key, pair<Key, Val>>;\n\
    \    using HashMapImpl::HashMapBase<Key, pair<Key, Val>>::HashMapBase;\n    using\
    \ Data = pair<Key, Val>;\n\n    Val &operator[](const Key &k) {\n        typename\
    \ base::u32 h = base::inner_hash(k);\n        while (true) {\n            if (base::flag[h]\
    \ == false) {\n                if (base::extend_rate(base::s + 1)) {\n       \
    \             base::extend();\n                    h = base::hash(k);\n      \
    \              continue;\n                }\n                base::data[h].first\
    \ = k;\n                base::data[h].second = Val();\n                base::flag[h]\
    \ = true;\n                ++base::s;\n                return base::data[h].second;\n\
    \            }\n            if (base::data[h].first == k) {\n                if\
    \ (base::dflag[h] == true) base::data[h].second = Val();\n                return\
    \ base::data[h].second;\n            }\n            h = (h + 1) & (base::cap -\
    \ 1);\n        }\n    }\n\n    typename base::itr emplace(const Key &key, const\
    \ Val &val) {\n        return base::insert(Data(key, val));\n    }\n\n    bool\
    \ count(const Key &k) {\n        return this->contain(k);\n    }\n};\n#line 4\
    \ \"src/common/Counter.hpp\"\n\ntemplate<typename T>\nHashMap<T, ll> Counter(const\
    \ vector<T> &A) {\n    HashMap<T, ll> res;\n    for (T a : A) {\n        res[a]++;\n\
    \    }\n    return res;\n}\n\ntemplate<typename T>\nvector<ll> Counter(const vector<T>\
    \ &A, int mx) {\n    vector<ll> res(mx + 1);\n    for (T a : A) {\n        res[a]++;\n\
    \    }\n    return res;\n}\n\nHashMap<char, ll> Counter(const string &S) {\n \
    \   HashMap<char, ll> res;\n    for (char c : S) {\n        res[c]++;\n    }\n\
    \    return res;\n}\n\ntemplate<typename T>\nvector<pair<ll, T>> most_common(const\
    \ HashMap<T, ll> &C) {\n    vector<pair<ll, T>> res;\n    for (auto [k, v] : C)\
    \ {\n        res.eb(v, k);\n    }\n    sort(res.rbegin(), res.rend());\n    return\
    \ res;\n}\n#line 3 \"src/common/RLE.hpp\"\n\n// \u30E9\u30F3\u30EC\u30F3\u30B0\
    \u30B9\u5727\u7E2E\ntemplate<typename T>\nvector<pair<T, int>> RLE(const vector<T>\
    \ &A) {\n    if (A.empty()) return {};\n    int N = A.size();\n    vector<pair<T,\
    \ int>> res;\n    T cur = A[0];\n    int cnt = 1;\n    rep(i, 1, N) {\n      \
    \  if (A[i] == A[i - 1]) {\n            cnt++;\n        } else {\n           \
    \ res.pb({cur, cnt});\n            cnt = 1;\n            cur = A[i];\n       \
    \ }\n    }\n    res.pb({cur, cnt});\n    return res;\n}\n\n// \u30E9\u30F3\u30EC\
    \u30F3\u30B0\u30B9\u5727\u7E2E(\u6587\u5B57\u5217)\nvector<pair<char, int>> RLE(const\
    \ string &S) {\n    if (S.empty()) return {};\n    int N = S.size();\n    vector<pair<char,\
    \ int>> res;\n    char cur = S[0];\n    int cnt = 1;\n    rep(i, 1, N) {\n   \
    \     if (S[i] == S[i - 1]) {\n            cnt++;\n        } else {\n        \
    \    res.pb({cur, cnt});\n            cnt = 1;\n            cur = S[i];\n    \
    \    }\n    }\n    res.pb({cur, cnt});\n    return res;\n}\n#line 3 \"src/common/bisearch.hpp\"\
    \n\n// (mn,mx]\u306E\u7BC4\u56F2\u3067\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6700\
    \u5C0F\u5024\u3092\u898B\u3064\u3051\u308B\u4E8C\u5206\u63A2\u7D22\ntemplate<typename\
    \ F>\nll bisearch_min(ll mn, ll mx, const F &func) {\n    ll ok = mx;\n    ll\
    \ ng = mn;\n    while (ng + 1 < ok) {\n        ll mid = (ok + ng) / 2;\n     \
    \   if (func(mid)) {\n            // \u4E0B\u3092\u63A2\u3057\u306B\u884C\u304F\
    \n            ok = mid;\n        } else {\n            // \u4E0A\u3092\u63A2\u3057\
    \u306B\u884C\u304F\n            ng = mid;\n        }\n    }\n    return ok;\n\
    }\n\n// [mn,mx)\u306E\u7BC4\u56F2\u3067\u6761\u4EF6\u3092\u6E80\u305F\u3059\u6700\
    \u5927\u5024\u3092\u898B\u3064\u3051\u308B\u4E8C\u5206\u63A2\u7D22\ntemplate<typename\
    \ F>\nll bisearch_max(ll mn, ll mx, const F &func) {\n    ll ok = mn;\n    ll\
    \ ng = mx;\n    while (ok + 1 < ng) {\n        ll mid = (ok + ng) / 2;\n     \
    \   if (func(mid)) {\n            // \u4E0A\u3092\u63A2\u3057\u306B\u884C\u304F\
    \n            ok = mid;\n        } else {\n            // \u4E0B\u3092\u63A2\u3057\
    \u306B\u884C\u304F\n            ng = mid;\n        }\n    }\n    return ok;\n\
    }\n#line 3 \"src/common/bisect.hpp\"\n\ntemplate<typename T>\nint bisect_left(const\
    \ vector<T> &A, T val, int lo = 0) {\n    return lower_bound(A.begin() + lo, A.end(),\
    \ val) - A.begin();\n}\n\ntemplate<typename T>\nint bisect_right(const vector<T>\
    \ &A, T val, int lo = 0) {\n    return upper_bound(A.begin() + lo, A.end(), val)\
    \ - A.begin();\n}\n#line 3 \"src/common/bit_length.hpp\"\n\nint bit_length(ll\
    \ x) {\n    int res = 0;\n    while (x) {\n        res++;\n        x /= 2;\n \
    \   }\n    return res;\n}\n#line 2 \"src/common/ceil.hpp\"\n\ntemplate<typename\
    \ T>\nT ceil(T a, T b) {\n    if (a >= 0) return (a + b - 1) / b;\n    else return\
    \ a / b;\n}\n#line 2 \"src/common/chmax.hpp\"\n\ntemplate<typename T>\nbool chmax(T\
    \ &x, T y) {\n    return (y > x) ? x = y, true : false;\n}\n#line 2 \"src/common/chmin.hpp\"\
    \n\ntemplate<typename T>\nbool chmin(T &x, T y) {\n    return (y < x) ? x = y,\
    \ true : false;\n}\n#line 3 \"src/common/concat.hpp\"\n\n// \u914D\u5217\u306E\
    \u9023\u7D50\ntemplate<typename T, typename... Ts>\nvector<T> concat(const vector<T>\
    \ &A, const vector<T> &B, Ts... args) {\n    vector<T> res = A;\n    res.insert(res.end(),\
    \ B.begin(), B.end());\n    if constexpr (sizeof...(Ts) == 0) {\n        return\
    \ res;\n    } else {\n        return concat(res, args...);\n    }\n}\n#line 3\
    \ \"src/common/divmod.hpp\"\n\ntemplate<typename T>\npair<T, T> divmod(T a, T\
    \ b) {\n    T d = a / b;\n    T m = a % b;\n    return {d, m};\n}\n#line 3 \"\
    src/common/input.hpp\"\n\n// pair\u5165\u529B\u4E00\u62EC\u53D7\u3051\u53D6\u308A\
    \ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1,\
    \ T2> &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\n// vector\u5165\
    \u529B\u4E00\u62EC\u53D7\u3051\u53D6\u308A\ntemplate<typename T>\nistream &operator>>(istream\
    \ &is, vector<T> &v) {\n    for (T &in : v) is >> in;\n    return is;\n}\n\n//\
    \ \u203B\u6700\u8FD1\u306F\u3082\u3046\u305A\u3063\u3068vector\u306E\u53D7\u3051\
    \u53D6\u308A\u306Foperator>>\u306A\u306E\u3067\u3001\u3053\u308C\u306F\u3082\u3046\
    \u8981\u3089\u306A\u3044\u304B\u3082\u3002\n// template<typename T = ll>\n// vector<T>\
    \ LIST(ll N) {\n//     vector<T> A(N);\n//     rep(i, N) {\n//         cin >>\
    \ A[i];\n//     }\n//     return A;\n// }\n#line 3 \"src/common/to_string.hpp\"\
    \n\nstring to_string(const string &S) {\n    return S;\n}\n\nstring to_string(char\
    \ c) {\n    return {c};\n}\n#line 4 \"src/common/join.hpp\"\n\ntemplate<typename\
    \ T>\nstring join(const vector<T> &A, string separator = \"\") {\n    int N =\
    \ A.size();\n    string res;\n    rep(i, N) {\n        res += tostr(A[i]);\n \
    \       if (i != N - 1) res += separator;\n    }\n    return res;\n}\n#line 3\
    \ \"src/common/listnd.hpp\"\n\n// \u4EFB\u610F\u6B21\u5143vector\n// \u53C2\u8003\
    \uFF1Ahttps://luzhiled1333.github.io/comp-library/src/cpp-template/header/make-vector.hpp\n\
    template<typename... Ts>\nauto listnd(size_t N, Ts... ts) {\n    if constexpr\
    \ (sizeof...(ts) == 1) {\n        return vector<Ts...>(N, ts...);\n    } else\
    \ {\n        auto res = listnd(ts...);\n        return vector<decltype(res)>(N,\
    \ res);\n    }\n}\n\n// \u5F8C\u65B9\u4E92\u63DB\ntemplate<typename T>[[deprecated(\"\
    list2d will be merged with listnd\")]] vv<T> list2d(int N, int M, T init) { return\
    \ listnd(N, M, init); }\ntemplate<typename T>[[deprecated(\"list3d will be merged\
    \ with listnd\")]] vv<vector<T>> list3d(int N, int M, int L, T init) { return\
    \ listnd(N, M, L, init); }\ntemplate<typename T>[[deprecated(\"list4d will be\
    \ merged with listnd\")]] vv<vv<T>> list4d(int N, int M, int L, int O, T init)\
    \ { return listnd(N, M, L, O, init); }\n#line 4 \"src/common/max.hpp\"\n\ntemplate<typename\
    \ T>\nT max(const vector<T> &A) {\n    assert(not A.empty());\n    return *max_element(ALL(A));\n\
    }\n\ntemplate<typename key, typename val>\nval max(const map<key, val> &mp) {\n\
    \    val res = numeric_limits<val>::min();\n    for (auto &[k, v] : mp) chmax(res,\
    \ v);\n    return res;\n}\n#line 4 \"src/common/min.hpp\"\n\ntemplate<typename\
    \ T>\nT min(const vector<T> &A) {\n    assert(not A.empty());\n    return *min_element(ALL(A));\n\
    }\n\ntemplate<typename key, typename val>\nval min(const map<key, val> &mp) {\n\
    \    val res = numeric_limits<val>::max();\n    for (auto &[k, v] : mp) chmin(res,\
    \ v);\n    return res;\n}\n#line 2 \"src/common/modulo.hpp\"\n\ntemplate<typename\
    \ T>\nT modulo(T a, T b) {\n    return ((a % b) + b) % b;\n}\n#line 2 \"src/common/overflow.hpp\"\
    \n\n// \u4E57\u7B97\u306E\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u691C\u77E5\
    \n// \u53C2\u8003\uFF1Ahttps://rsk0315.hatenablog.com/entry/2021/02/23/163040\n\
    template<typename T>\nbool mul_overflow(T x, T y) {\n    T z;\n    return __builtin_mul_overflow(x,\
    \ y, &z);\n}\n\n// \u52A0\u7B97\u306E\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\
    \u691C\u77E5\ntemplate<typename T>\nbool add_overflow(T x, T y) {\n    T z;\n\
    \    return __builtin_add_overflow(x, y, &z);\n}\n#line 3 \"src/common/pair.hpp\"\
    \n\n// pair\u306E\u56DB\u5247\u8A08\u7B97\ntemplate<class T, class U>\ninline\
    \ pair<T, U> &operator+=(pair<T, U> &a, const pair<T, U> &b) {\n    a.fi += b.fi;\n\
    \    a.se += b.se;\n    return a;\n}\ntemplate<class T, class U>\ninline pair<T,\
    \ U> &operator-=(pair<T, U> &a, const pair<T, U> &b) {\n    a.fi -= b.fi;\n  \
    \  a.se -= b.se;\n    return a;\n}\ntemplate<class T, class U>\ninline pair<T,\
    \ U> &operator*=(pair<T, U> &a, const pair<T, U> &b) {\n    a.fi *= b.fi;\n  \
    \  a.se *= b.se;\n    return a;\n}\ntemplate<class T, class U>\ninline pair<T,\
    \ U> &operator/=(pair<T, U> &a, const pair<T, U> &b) {\n    a.fi /= b.fi;\n  \
    \  a.se /= b.se;\n    return a;\n}\n\n// \u30A4\u30F3\u30AF\u30EA\u30E1\u30F3\u30C8\
    \u30FB\u30C7\u30AF\u30EA\u30E1\u30F3\u30C8\ntemplate<class T, class U>\nconstexpr\
    \ void operator++(pair<T, U> &a, int) noexcept {\n    a.first++;\n    a.second++;\n\
    }\ntemplate<class T, class U>\nconstexpr void operator--(pair<T, U> &a, int) noexcept\
    \ {\n    a.first--;\n    a.second--;\n}\n#line 3 \"src/common/popcount.hpp\"\n\
    \nint popcount(ll S) {\n    return __builtin_popcountll(S);\n}\n#line 3 \"src/common/pow.hpp\"\
    \n\nll pow(ll x, ll n) {\n    ll res = 1;\n    rep(_, n) res *= x;\n    return\
    \ res;\n}\n\nll pow(int x, ll n) {\n    return pow((ll)x, n);\n}\n\nll pow(ll\
    \ x, int n) {\n    return pow(x, (ll)n);\n}\n\nll pow(int x, int n) {\n    return\
    \ pow((ll)x, (ll)n);\n}\n\ntemplate<typename T1, typename T2, typename M>\nT1\
    \ pow(T1 x, T2 n, M mod) {\n    x %= mod;\n    T1 res = 1;\n    while (n > 0)\
    \ {\n        if (n & 1) {\n            assert(not mul_overflow(res, x));\n   \
    \         res = (res * x) % mod;\n        }\n        assert(not mul_overflow(x,\
    \ x));\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return res;\n\
    }\n#line 3 \"src/common/print.hpp\"\n\n// pair\ntemplate<typename T1, typename\
    \ T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os\
    \ << p.first << ' ' << p.second;\n}\n\n// tuple\n// see: https://gist.github.com/naskya/1e5e5cd269cfe16a76988378a60e2ca3#file-debug_print-hpp-L150\n\
    template<class T, size_t... Is>\nvoid print_tuple(ostream &os, const T &arg, index_sequence<Is...>)\
    \ {\n    static_cast<void>(((os << (Is == 0 ? \"\" : \" \"), os << get<Is>(arg)),\
    \ ...));\n}\ntemplate<class... Ts>\nostream &operator<<(ostream &os, const tuple<Ts...>\
    \ &arg) {\n    print_tuple(os, arg, make_index_sequence<sizeof...(Ts)>());\n \
    \   return os;\n}\n\n// \u65E7\u4ED5\u69D8\u3002\u65B0\u4ED5\u69D8\u3067\u3042\
    \u308B\u7A0B\u5EA6\u52D5\u4F5C\u554F\u984C\u306A\u3044\u78BA\u8A8D\u304C\u53D6\
    \u308C\u305F\u3089\u524A\u9664\n// template<typename T1, typename T2, typename\
    \ T3>\n// ostream &operator<<(ostream &os, const tuple<T1, T2, T3> &tp) {\n//\
    \     return os << get<0>(tp) << ' ' << get<1>(tp) << ' ' << get<2>(tp);\n// }\n\
    // template<typename T1, typename T2, typename T3, typename T4>\n// ostream &operator<<(ostream\
    \ &os, const tuple<T1, T2, T3, T4> &tp) {\n//     return os << get<0>(tp) << '\
    \ ' << get<1>(tp) << ' ' << get<2>(tp) << ' ' << get<3>(tp);\n// }\n// template<typename\
    \ T1, typename T2, typename T3>\n// void print(const tuple<T1, T2, T3> &tp) {\n\
    //     cout << get<0>(tp) << ' ' << get<1>(tp) << ' ' << get<2>(tp) << '\\n';\n\
    // }\n// template<typename T1, typename T2, typename T3, typename T4>\n// void\
    \ print(const tuple<T1, T2, T3, T4> &tp) {\n//     cout << get<0>(tp) << ' ' <<\
    \ get<1>(tp) << ' ' << get<2>(tp) << ' ' << get<3>(tp) << '\\n';\n// }\n\n// vector\n\
    template<typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\
    \    rep(i, vec.size()) {\n        os << vec[i];\n        if (i != (int)vec.size()\
    \ - 1) {\n            os << ' ';\n        }\n    }\n    return os;\n}\ntemplate<typename\
    \ T>\nvoid print(const vector<T> &vec, string sep = \" \") {\n    rep(i, vec.size())\
    \ {\n        cout << vec[i];\n        if (i != (int)vec.size() - 1) cout << sep;\n\
    \    }\n    cout << '\\n';\n}\n\n// array\ntemplate<typename T, size_t N>\nostream\
    \ &operator<<(ostream &os, const array<T, N> &arr) {\n    rep(i, N) {\n      \
    \  os << arr[i];\n        if (i != (int)N - 1) {\n            os << ' ';\n   \
    \     }\n    }\n    return os;\n}\ntemplate<typename T, size_t N>\nvoid print(const\
    \ array<T, N> &arr, string sep = \" \") {\n    rep(i, N) {\n        cout << arr[i];\n\
    \        if (i != (int)N - 1) cout << sep;\n    }\n    cout << '\\n';\n}\n\n//\
    \ deque\ntemplate<typename T>\nvoid print(const deque<T> &que, string sep = \"\
    \ \") {\n    vector<T> vec(ALL(que));\n    print(vec, sep);\n}\n\n// set\ntemplate<typename\
    \ T>\nvoid print(const set<T> &se, string sep = \" \") {\n    vector<T> vec(ALL(se));\n\
    \    print(vec, sep);\n}\n\n// set, multiset, deque, etc...\n// \u203B\u3068\u3066\
    \u3082\u6C4E\u7528\u6027\u9AD8\u3044\u3093\u3060\u3051\u3069\u3001string\u307E\
    \u3067\u53D6\u308A\u8FBC\u307E\u308C\u3066vector\u306B\u3055\u308C\u3066\u3057\
    \u307E\u3046\u306E\u3067\u4F7F\u308F\u306A\u3044\n// template<template<typename\
    \ T>class Container, typename T>\n// void print(const Container<T>& con, string\
    \ sep=\" \") {\n//     vector<T> V(ALL(con));\n//     print(V, sep);\n// }\n\n\
    // initializer_list (\u300Cprint({1, 2, 3, 4});\u300D\u3068\u304B\u3067\u304D\u308B\
    )\ntemplate<typename T>\nvoid print(const initializer_list<T> &li, string sep\
    \ = \" \") {\n    vector<T> V(ALL(li));\n    print(V, sep);\n}\n\n// \u53EF\u5909\
    \u9577\u5F15\u6570\u3002operator<<\u304C\u5B9A\u7FA9\u3055\u308C\u3066\u3055\u3048\
    \u3044\u308C\u3070\u3001\u578B\u304C\u9055\u3046\u540C\u58EB\u3067\u3082\u96D1\
    \u591A\u306B\u4E26\u3079\u3066\u51FA\u529B\u3067\u304D\u308B\n// \u203Bprint(vector,\
    \ \"\\n\")\u3068\u304B\u3082\u3053\u3053\u306B\u6765\u3066\u3057\u307E\u3063\u305F\
    \u306E\u3067\u4E00\u65E6\u4E2D\u6B62\n// template<typename T, typename... Ts>\n\
    // void print(const T val, Ts... ts) {\n//     if constexpr (sizeof...(Ts) ==\
    \ 0) {\n//         cout << val << '\\n';\n//     } else {\n//         cout <<\
    \ val << ' ';\n//         print(ts...);\n//     }\n// }\n\n// \u6539\u884C\u306E\
    \u307F\nvoid print() {\n    cout << '\\n';\n}\n\n// \u305D\u306E\u4ED6 (pair,tuple,string\u7B49\
    \u3082\u3053\u3053\u306B\u6765\u3066operator<<\u306B\u6E21\u3055\u308C\u308B)\n\
    template<typename T>\nvoid print(T out) {\n    cout << out << '\\n';\n}\n\n//\
    \ debug (\u5909\u6570\u540D\u4ED8\u304D\u3067\u51FA\u529B\u3001stderr\u306A\u306E\
    \u3067\u63D0\u51FA\u3092\u90AA\u9B54\u3057\u306A\u3044)\n// #define debug(x) (cerr\
    \ << #x << \": \" << x << endl);\n// \u53EF\u5909\u9577\u5F15\u6570\u5BFE\u5FDC\
    \u7248\n// see: https://blog.naskya.net/post/meu0vkh5cpl1/\n#define debug(...)\
    \ multi_debug(#__VA_ARGS__, __VA_ARGS__)\ntemplate<class Tp, class... Ts>\nvoid\
    \ multi_debug(string names, Tp arg, Ts... args) {\n    // args...\u306E\u30D1\u30E9\
    \u30E1\u30FC\u30BF\u304C0\u500B\u306E\u3068\u304D\u3001\u5358\u306Barg\u3060\u3051\
    \u3092\u51FA\u529B\u3057\u3066\u7D42\u4E86\n    if constexpr (sizeof...(Ts) ==\
    \ 0) {\n        while (names.back() == ' ') {\n            names.pop_back();\n\
    \        }\n        cerr << names << \": \" << arg << endl;\n    } else {\n  \
    \      // names\u306B\u306F\u5168\u90E8\u306E\u5909\u6570\u306E\u540D\u524D\u304C\
    \u683C\u7D0D\u3055\u308C\u3066\u3044\u308B\u306E\u3067\u30011\u3064\u76EE\u306E\
    \u5909\u6570\u540D\u306E\u7D42\u308F\u308A\u306E','\u306E\u4F4D\u7F6E\u3092\u63A2\
    \u3059\n        int n = names.size(), comma_pos = -1, paren_depth = 0,\n     \
    \       inside_quote = false;\n        rep(i, n) {\n            if (not inside_quote\
    \ and paren_depth == 0 and names[i] == ',') {\n                comma_pos = i;\n\
    \                break;\n            }\n            if (names[i] == '\\\"' or\
    \ names[i] == '\\'') {\n                if (i > 0 and names[i - 1] == '\\\\')\
    \ continue;\n                inside_quote ^= true;\n            }\n          \
    \  if (not inside_quote and names[i] == '(') {\n                paren_depth++;\n\
    \            }\n            if (not inside_quote and names[i] == ')') {\n    \
    \            paren_depth--;\n            }\n        }\n        assert(comma_pos\
    \ != -1);\n        string name = names.substr(0, comma_pos);\n        while (name.back()\
    \ == ' ') {\n            name.pop_back();\n        }\n        cerr << name <<\
    \ \": \" << arg << endl;\n\n        int next_begin_at = comma_pos + 1;\n     \
    \   while (names[next_begin_at] == ' ') {\n            next_begin_at++;\n    \
    \    }\n        names = names.substr(next_begin_at);\n        // \u3053\u306E\u95A2\
    \u6570\u3092\u518D\u5E30\u7684\u306B\u547C\u3093\u3067\u6B8B\u308A\u306E\u5909\
    \u6570\u3082\u51FA\u529B\u3059\u308B\n        multi_debug(names, args...);\n \
    \   }\n}\n\n// \u5F8C\u65B9\u4E92\u63DB\ntemplate<typename T>\nvoid print(const\
    \ vector<T> &V, char sep) {\n    print(V, string{sep});\n}\ntemplate<typename\
    \ T, size_t N>\nvoid print(const array<T, N> &arr, char sep) {\n    print(arr,\
    \ string{sep});\n}\n\n// TODO\uFF1A\u305D\u306E\u3046\u3061\u81EA\u52D5\u5B9F\u884C\
    \u3068\u304B\u3067\u304D\u308B\u3088\u3046\u306B\u3059\u308B\u3002\n// test cases\
    \ for print() and cout <<\n// pair<char, int> p = {'a', 1};\n// cout << p << '\\\
    n';\n// print(p);\n// tuple<char, int, ll, string> tp = {'a', 1, 2, \"abc\"};\n\
    // cout << tp << '\\n';\n// print(tp);\n// vector<ll> vec = {1, 2, 3, 4, 5};\n\
    // cout << vec << '\\n';\n// print(vec);\n// print(vec, \"\\n\");\n// array<ll,\
    \ 5> arr = {1, 2, 3, 4, 5};\n// cout << arr << '\\n';\n// print(arr);\n// print(arr,\
    \ \"\\n\");\n// deque<ll> que = {1, 2, 3, 4, 5};\n// print(que);\n// print(que,\
    \ \"\\n\");\n// set<ll> se = {1, 2, 3, 4, 5};\n// print(se);\n// print(se, \"\\\
    n\");\n// print({1, 2, 3, 4, 5});\n// print({1, 2, 3, 4, 5}, \"\\n\");\n// print();\n\
    // ll a = 100;\n// cout << a << '\\n';\n// print(a);\n// print(100);\n// string\
    \ S = \"abc\";\n// cout << S << '\\n';\n// print(S);\n// print(\"abc\");\n// char\
    \ c = 'a';\n// cout << c << '\\n';\n// print(c);\n// print('a');\n// // print(1,\
    \ \"abc\", 22LL);\n// // print(s, c);\n\n// test cases for debug()\n// int a =\
    \ 2;\n// string b = \"agc\";\n// char c = 'z';\n// ll d = 10000;\n// debug(a,\
    \  b, \"aaa\", 'y', c,d, max((ll)a, d));\n#line 3 \"src/common/reversed.hpp\"\n\
    \ntemplate<typename T>\nvector<T> reversed(vector<T> A) {\n    reverse(ALL(A));\n\
    \    return A;\n}\n\nstring reversed(string S) {\n    reverse(ALL(S));\n    return\
    \ S;\n}\n#line 3 \"src/common/sorted.hpp\"\n\ntemplate<typename T>\nvector<T>\
    \ sorted(vector<T> A, bool reverse = false) {\n    sort(ALL(A));\n    if (reverse)\
    \ std::reverse(ALL(A));\n    return A;\n}\n\nstring sorted(string S, bool reverse\
    \ = false) {\n    sort(ALL(S));\n    if (reverse) std::reverse(ALL(S));\n    return\
    \ S;\n}\n#line 3 \"src/common/toint.hpp\"\n\nll toint(string s) {\n    assert(s.size()\
    \ < 20);\n    ll res = 0;\n    for (char &c : s) {\n        res *= 10;\n     \
    \   res += c - '0';\n    }\n    return res;\n}\n\nint toint(char num) {\n    return\
    \ num - '0';\n}\n#line 4 \"src/common/split.hpp\"\n\n// \u203Bint\u5909\u63DB\u306F\
    \u5225\u9014\u5BFE\u5FDC\u3059\u308B\n// vector<ll> split(const string &S, char\
    \ separator) {\n//     int N = S.size();\n//     vector<ll> res;\n//     string\
    \ cur;\n//     rep(i, N) {\n//         if (S[i] == separator) {\n//          \
    \   res.eb(toint(cur));\n//             cur = \"\";\n//         } else {\n// \
    \            cur += S[i];\n//         }\n//     }\n//     if (cur.size()) res.eb(toint(cur));\n\
    //     return res;\n// }\n\n// \u6587\u5B57\u5217\u306E\u307E\u307E\u7248\nvector<string>\
    \ split(const string &S, char separator) {\n    int N = S.size();\n    vector<string>\
    \ res;\n    string cur;\n    rep(i, N) {\n        if (S[i] == separator) {\n \
    \           res.eb(cur);\n            cur = \"\";\n        } else {\n        \
    \    cur += S[i];\n        }\n    }\n    if (cur.size()) res.eb(cur);\n    return\
    \ res;\n}\n#line 3 \"src/common/subarray.hpp\"\n\n// \u914D\u5217\u306E\u90E8\u5206\
    \u5217\u53D6\u5F97\n// (\u672C\u5F53\u306F\u300Cslice\u300D\u304C\u4F7F\u3044\u305F\
    \u3044\u3093\u3060\u3051\u3069\u3001std::slice\u3068\u540D\u524D\u885D\u7A81\u3059\
    \u308B\u306E\u3067\u3068\u308A\u3042\u3048\u305Asubarray\u306B\u3057\u3066\u304A\
    \u304F\u3002)\ntemplate<typename T>\nvector<T> subarray(const vector<T> &A, int\
    \ l, int r) {\n    return vector<T>(A.begin() + l, A.begin() + r);\n}\n#line 3\
    \ \"src/common/sum.hpp\"\n\ntemplate<typename T>\nT sum(const vector<T> &A) {\n\
    \    return accumulate(ALL(A), (T)0);\n}\n\ntemplate<typename key, typename val>\n\
    val sum(const map<key, val> &mp) {\n    val res = 0;\n    for (auto &[k, v] :\
    \ mp) res += v;\n    return res;\n}\n#line 2 \"src/common/tochar.hpp\"\n\nchar\
    \ tochar(int num) {\n    return '0' + num;\n}\n#line 3 \"src/common/vector.hpp\"\
    \n\n// \u53C2\u8003\uFF1Ahttps://twitter.com/stoq_/status/1484211267510288384\n\
    template<typename T>\nconstexpr void operator--(vector<T> &vec, int) noexcept\
    \ {\n    rep(i, vec.size()) vec[i]--;\n}\n\ntemplate<typename T>\nconstexpr void\
    \ operator++(vector<T> &vec, int) noexcept {\n    rep(i, vec.size()) vec[i]++;\n\
    }\n#line 3 \"src/common/yesno.hpp\"\n\nvoid Yes() {\n    print(\"Yes\");\n}\n\n\
    void No() {\n    print(\"No\");\n}\n\nvoid YES() {\n    print(\"YES\");\n}\n\n\
    void NO() {\n    print(\"NO\");\n}\n\nvoid YESNO(bool f) {\n    print(f ? \"YES\"\
    \ : \"NO\");\n}\n\nvoid YesNo(bool f) {\n    print(f ? \"Yes\" : \"No\");\n}\n\
    \nvoid yesno(bool f) {\n    print(f ? \"yes\" : \"no\");\n}\n#line 3 \"src/common/zip.hpp\"\
    \n\ntemplate<typename T1, typename T2>\npair<vector<T1>, vector<T2>> zip(const\
    \ vector<pair<T1, T2>> &A) {\n    int N = A.size();\n    pair<vector<T1>, vector<T2>>\
    \ res = {vector<T1>(N), vector<T2>(N)};\n    rep(i, N) {\n        res.first[i]\
    \ = A[i].first;\n        res.second[i] = A[i].second;\n    }\n    return res;\n\
    }\n\ntemplate<typename T1, typename T2, typename T3>\ntuple<vector<T1>, vector<T2>,\
    \ vector<T3>> zip(const vector<tuple<T1, T2, T3>> &A) {\n    int N = A.size();\n\
    \    tuple<vector<T1>, vector<T2>, vector<T3>> res = {\n        vector<T1>(N),\
    \ vector<T2>(N), vector<T3>(N)\n    };\n    rep(i, N) {\n        get<0>(res)[i]\
    \ = get<0>(A[i]);\n        get<1>(res)[i] = get<1>(A[i]);\n        get<2>(res)[i]\
    \ = get<2>(A[i]);\n    }\n    return res;\n}\n#line 39 \"src/template.hpp\"\n\n\
    // from combinatorics\n#line 3 \"src/combinatorics/ModTools.hpp\"\n\n// Mod\u6570\
    \u3048\u4E0A\u3052\u6F14\u7B97\u30C4\u30FC\u30EB\ntemplate<typename Mint>\nstruct\
    \ ModTools {\nprivate:\n    int MAX;\n    vector<Mint> _fact, _factinv, inv;\n\
    \npublic:\n    // nCr\u306A\u3089n\u3001nHr\u306A\u3089n+r\u307E\u3067\u4F5C\u308B\
    \n    ModTools(int mx) : MAX(++mx) {\n        _fact.resize(MAX);\n        _factinv.resize(MAX);\n\
    \        inv.resize(MAX);\n        _fact[0] = _fact[1] = 1;\n        rep(i, 2,\
    \ MAX) {\n            _fact[i] = _fact[i - 1] * (Mint)i;\n        }\n        _factinv[MAX\
    \ - 1] = (Mint)1 / _fact[MAX - 1];\n        rep(i, MAX - 2, -1, -1) {\n      \
    \      _factinv[i] = _factinv[i + 1] * (Mint)(i + 1);\n        }\n        rep(i,\
    \ MAX - 1, 0, -1) {\n            inv[i] = _factinv[i] * _fact[i - 1];\n      \
    \  }\n    }\n\n    // \u6E96\u5099O(N)\u3001\u64CD\u4F5CO(1)\u3067log\u304C\u4E57\
    \u3089\u306A\u3044mod\u9664\u7B97\n    Mint div(Mint a, int b) {\n        return\
    \ a * inv[b];\n    }\n\n    Mint fact(int x) {\n        assert(x < MAX);\n   \
    \     return _fact[x];\n    }\n\n    Mint factinv(int x) {\n        assert(x <\
    \ MAX);\n        return _factinv[x];\n    }\n\n    Mint nCr(int n, int r) {\n\
    \        if (n < r or r < 0) return 0;\n        r = min(r, n - r);\n        Mint\
    \ num = _fact[n];\n        Mint den = _factinv[r] * _factinv[n - r];\n       \
    \ return num * den;\n    }\n\n    Mint nHr(int n, int r) {\n        assert(r +\
    \ n - 1 < MAX);\n        return nCr(r + n - 1, r);\n    }\n\n    Mint nPr(int\
    \ n, int r) {\n        if (n < r or r < 0) return 0;\n        return _fact[n]\
    \ * _factinv[n - r];\n    }\n\n    // \u4E8C\u91CD\u968E\u4E57\n    // \u53C2\u8003\
    \uFF1Ahttps://ja.wikipedia.org/wiki/%E4%BA%8C%E9%87%8D%E9%9A%8E%E4%B9%97\n   \
    \ Mint double_factorial(int n) {\n        if (n % 2 == 0) {\n            int k\
    \ = n / 2;\n            return Mint(2).pow(k) * fact(k);\n        } else {\n \
    \           int k = (n + 1) / 2;\n            return fact(2 * k) / Mint(2).pow(k)\
    \ / fact(k);\n        }\n    }\n};\n#line 3 \"src/combinatorics/combinations.hpp\"\
    \n\n// \u7D44\u307F\u5408\u308F\u305B\u5168\u5217\u6319\ntemplate<typename T>\n\
    vv<T> combinations(const vector<T> &A, int N) {\n    int M = A.size();\n    vv<T>\
    \ res;\n    auto rec = [&](auto &&f, vector<T> &cur, int x, int n) -> void {\n\
    \        if (n == N) {\n            res.pb(cur);\n            return;\n      \
    \  }\n        rep(i, x, M) {\n            cur.pb(A[i]);\n            f(f, cur,\
    \ i + 1, n + 1);\n            cur.pop_back();\n        }\n    };\n    vector<T>\
    \ cur;\n    rec(rec, cur, 0, 0);\n    return res;\n}\n#line 3 \"src/combinatorics/nC2.hpp\"\
    \n\nll nC2(ll n) {\n    if (n < 2) return 0;\n    return n * (n - 1) / 2;\n}\n\
    #line 3 \"src/combinatorics/permutations.hpp\"\n\n// \u9806\u5217\u5168\u5217\u6319\
    \ntemplate<typename T>\nvv<T> permutations(const vector<T> &A, int N = -1) {\n\
    \    if (N == -1) N = A.size();\n    int M = A.size();\n    assert(N <= M);\n\
    \    vv<T> comb;\n    rep(bit, 1 << M) {\n        if (popcount(bit) != N) continue;\n\
    \        vector<T> res;\n        rep(i, M) {\n            if (bit >> i & 1) {\n\
    \                res.pb(A[i]);\n            }\n        }\n        comb.pb(res);\n\
    \    }\n\n    vv<T> res;\n    for (auto &perm : comb) {\n        sort(ALL(perm));\n\
    \        do {\n            res.pb(perm);\n        } while (next_permutation(ALL(perm)));\n\
    \    }\n    return res;\n}\n#line 45 \"src/template.hpp\"\n\n// from graph\n#line\
    \ 3 \"src/graph/UnionFind.hpp\"\n\nstruct UnionFind {\n    int n, groupcnt;\n\
    \    vector<int> par, rank, sz;\n    vector<bool> tree;\n\n    UnionFind(int n)\
    \ : n(n) {\n        build();\n    }\n\n    UnionFind() {}\n\n    // \u65E2\u5B58\
    \u306E\u9023\u7D50\u60C5\u5831\u304B\u3089UF\u3092\u751F\u6210\n    UnionFind(const\
    \ vector<int> &info) : n(info.size()) {\n        build();\n        vvi adj(n);\n\
    \        rep(i, n) {\n            adj[info[i]].eb(i);\n        }\n        rep(i,\
    \ n) {\n            if (adj[i].size()) {\n                rep(j, adj[i].size()\
    \ - 1) {\n                    merge(adj[i][j], adj[i][j + 1]);\n             \
    \   }\n            }\n        }\n    }\n\n    void build() {\n        par.assign(n,\
    \ 0);\n        rank.assign(n, 0);\n        sz.assign(n, 1);\n        tree.assign(n,\
    \ true);\n        rep(i, n) par[i] = i;\n        groupcnt = n;\n    }\n\n    void\
    \ resize(int _n) {\n        n = _n;\n        par.assign(n, 0);\n        rank.assign(n,\
    \ 0);\n        sz.assign(n, 1);\n        tree.assign(n, true);\n        rep(i,\
    \ n) par[i] = i;\n        groupcnt = n;\n    }\n\n    // \u6839(\u30B0\u30EB\u30FC\
    \u30D7\u756A\u53F7)\u306E\u691C\u7D22\n    virtual int find(int x) {\n       \
    \ if (par[x] == x) {\n            return x;\n        } else {\n            par[x]\
    \ = find(par[x]);\n            return par[x];\n        }\n    }\n\n    // \u4F75\
    \u5408\uFF1A\u30DE\u30FC\u30B8\u5F8C\u306E\u96C6\u5408\u306E\u6839(\u30DE\u30FC\
    \u30B8\u6E08\u306A\u3089-1)\u3092\u8FD4\u3059\n    template<typename F>\n    int\
    \ merge(int a, int b, F f) {\n        int x = find(a);\n        int y = find(b);\n\
    \        if (x == y) {\n            tree[x] = false;\n            f(-1, y);\n\
    \            return -1;\n        }\n        if (!tree[x] or !tree[y]) {\n    \
    \        tree[x] = tree[y] = false;\n        }\n        groupcnt--;\n        if\
    \ (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n\
    \            f(y, x);\n            return y;\n        } else {\n            par[y]\
    \ = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) {\n \
    \               rank[x]++;\n            }\n            f(x, y);\n            return\
    \ x;\n        }\n    }\n\n    int merge(int a, int b) {\n        return merge(a,\
    \ b, [](int r, int ch) {});\n    }\n\n    // \u540C\u3058\u96C6\u5408\u306B\u5C5E\
    \u3059\u308B\u304B\u5224\u5B9A\n    bool same(int a, int b) {\n        return\
    \ find(a) == find(b);\n    }\n\n    // \u3042\u308B\u30CE\u30FC\u30C9\u306E\u5C5E\
    \u3059\u308B\u96C6\u5408\u306E\u30CE\u30FC\u30C9\u6570\n    ll size(int x) {\n\
    \        return sz[find(x)];\n    }\n\n    // \u96C6\u5408\u306E\u6570\n    int\
    \ size() {\n        return groupcnt;\n    }\n\n    // \u6728\u304B\u3069\u3046\
    \u304B\u306E\u5224\u5B9A\n    bool is_tree(int x) {\n        return tree[find(x)];\n\
    \    }\n\n    // \u5168\u3066\u306E\u6839\u3092\u53D6\u5F97\n    set<int> get_roots()\
    \ {\n        set<int> res;\n        rep(i, n) {\n            res.insert(find(i));\n\
    \        }\n        return res;\n    }\n\n    // \u5168\u9802\u70B9\u306E\u30B0\
    \u30EB\u30FC\u30D7\u756A\u53F7\u3092\u53D6\u5F97\n    vector<int> get_info() {\n\
    \        vector<int> res(n);\n        rep(i, n) {\n            res[i] = find(i);\n\
    \        }\n        return res;\n    }\n};\n#line 48 \"src/template.hpp\"\n\n\
    // from grid\n#line 3 \"src/grid/constants/dir4.hpp\"\n\n// 4\u65B9\u5411\nconst\
    \ vector<pii> dir4 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n#line 3 \"src/grid/constants/directions.hpp\"\
    \n\n// \u5F8C\u65B9\u4E92\u63DB\u7528\n#define directions dir4\n#line 3 \"src/grid/gridtoid.hpp\"\
    \n\n// \u30B0\u30EA\u30C3\u30C9\u21D2\u5217\u5909\u63DB\nll gridtoid(ll i, ll\
    \ j, ll W) {\n    return i * W + j;\n}\n#line 4 \"src/grid/idtogrid.hpp\"\n\n\
    // \u5217\u21D2\u30B0\u30EA\u30C3\u30C9\u5909\u63DB\npll idtogrid(ll id, ll W)\
    \ {\n    return divmod(id, W);\n}\n#line 53 \"src/template.hpp\"\n\n// from mystl\n\
    #line 4 \"src/mystl/Deque.hpp\"\n\ntemplate<typename _Tp>\nstruct Deque : deque<_Tp>\
    \ {\n    using deque<_Tp>::deque;\n    _Tp pop_front() {\n        _Tp res = this->front();\n\
    \        deque<_Tp>::pop_front();\n        return res;\n    }\n    _Tp pop_back()\
    \ {\n        _Tp res = this->back();\n        deque<_Tp>::pop_back();\n      \
    \  return res;\n    }\n};\n\ntemplate<typename T>\nvoid print(const Deque<T> &que)\
    \ {\n    vector<T> V(que.begin(), que.end());\n    print(V);\n}\n#line 4 \"src/mystl/Multiset.hpp\"\
    \n\ntemplate<typename _Key>\nstruct Multiset : multiset<_Key> {\n    using multiset<_Key>::multiset;\n\
    \    _Key front() {\n        assert(this->size());\n        return *this->begin();\n\
    \    }\n    _Key pop_front() {\n        _Key res = this->front();\n        //\
    \ \u7A7A\u306E\u6642\u306B\u3053\u306E\u64CD\u4F5C\u3092\u3084\u308B\u3068\u63D0\
    \u51FA\u30D3\u30EB\u30C9\u3060\u3068RE\u3058\u3083\u306A\u304F\u3066TLE\u306B\u306A\
    \u308B\u2026\u3002\n        multiset<_Key>::erase(this->begin());\n        return\
    \ res;\n    }\n    _Key back() {\n        assert(this->size());\n        return\
    \ *this->rbegin();\n    }\n    _Key pop_back() {\n        _Key res = this->back();\n\
    \        multiset<_Key>::erase(prev(this->end()));\n        return res;\n    }\n\
    \    // count\u304CO(\u500B\u6570)\u3068\u306E\u8A71\u304C\u3042\u308B\u305F\u3081\
    \u5FF5\u306E\u305F\u3081\u4F5C\u3063\u3066\u304A\u304F\n    bool exist(_Key x)\
    \ {\n        return this->find(x) != this->end();\n    }\n    // 1\u500B\u524A\
    \u9664\n    auto erase(_Key x) {\n        return multiset<_Key>::erase(this->find(x));\n\
    \    }\n};\n\ntemplate<typename T>\nvoid print(const Multiset<T> &se) {\n    vector<T>\
    \ V(se.begin(), se.end());\n    print(V);\n}\n#line 3 \"src/mystl/PriorityQueue.hpp\"\
    \n\ntemplate<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare\
    \ = less<typename _Sequence::value_type>>\nstruct PriorityQueue : priority_queue<_Tp,\
    \ _Sequence, _Compare> {\n    using priority_queue<_Tp, _Sequence, _Compare>::priority_queue;\n\
    \    _Tp pop() {\n        _Tp res = this->top();\n        priority_queue<_Tp,\
    \ _Sequence, _Compare>::pop();\n        return res;\n    }\n};\n#line 4 \"src/mystl/Set.hpp\"\
    \n\ntemplate<typename _Key>\nstruct Set : set<_Key> {\n    using set<_Key>::set;\n\
    \    _Key front() {\n        assert(this->size());\n        return *this->begin();\n\
    \    }\n    _Key pop_front() {\n        _Key res = this->front();\n        this->erase(this->begin());\n\
    \        return res;\n    }\n    _Key back() {\n        assert(this->size());\n\
    \        return *this->rbegin();\n    }\n    _Key pop_back() {\n        _Key res\
    \ = this->back();\n        this->erase(prev(this->end()));\n        return res;\n\
    \    }\n};\n\ntemplate<typename T>\nvoid print(const Set<T> &se) {\n    vector<T>\
    \ V(se.begin(), se.end());\n    print(V);\n}\n#line 4 \"src/mystl/Vector.hpp\"\
    \n\ntemplate<typename _Tp>\nstruct Vector : vector<_Tp> {\n    // \u30B3\u30F3\
    \u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u7D99\u627F\n    using vector<_Tp>::vector;\n\
    \    _Tp pop() {\n        _Tp res = this->back();\n        this->pop_back();\n\
    \        return res;\n    }\n\n    template<typename F>\n    auto map(F f) {\n\
    \        Vector<decltype(f(_Tp()))> res;\n        for (auto &val : *this) {\n\
    \            res.eb(f(val));\n        }\n        return res;\n    }\n};\n\ntemplate<typename\
    \ T>\nvoid print(const Vector<T> &A) {\n    vector<T> V(A.begin(), A.end());\n\
    \    print(V);\n}\n#line 4 \"src/mystl/defaultdict.hpp\"\n\n// HashMap\u3092\u7D99\
    \u627F\u3057\u305Fdefaultdict\ntemplate<typename _Key, typename _Tp>\nstruct defaultdict\
    \ : HashMap<_Key, _Tp> {\n    const _Tp init;\n\n    defaultdict() : init(_Tp())\
    \ {};\n\n    defaultdict(_Tp init) : init(init) {}\n\n    _Tp &operator[](const\
    \ _Key &k) {\n        if (this->count(k)) {\n            return HashMap<_Key,\
    \ _Tp>::operator[](k);\n        } else {\n            return HashMap<_Key, _Tp>::operator[](k)\
    \ = init;\n        }\n    }\n\n    _Tp &operator[](_Key &&k) {\n        if (this->count(k))\
    \ {\n            return HashMap<_Key, _Tp>::operator[](k);\n        } else {\n\
    \            return HashMap<_Key, _Tp>::operator[](k) = init;\n        }\n   \
    \ }\n};\n#line 61 \"src/template.hpp\"\n\n// from numbers\n#line 3 \"src/numbers/divisors.hpp\"\
    \n\n// \u7D04\u6570\u5217\u6319\ntemplate<typename T>\nvector<T> divisors(T n)\
    \ {\n    vector<T> res;\n    for (T i = 1; i * i <= n; i++) {\n        if (n %\
    \ i == 0) {\n            res.eb(i);\n            if (n / i != i) res.eb(n / i);\n\
    \        }\n    }\n    // sort(ALL(res));\n    return res;\n}\n#line 3 \"src/numbers/factorize.hpp\"\
    \n\n// \u7D20\u56E0\u6570\u5206\u89E3(vector\u30D9\u30FC\u30B9)\ntemplate<typename\
    \ T>\nvector<pair<T, int>> factorize(T n) {\n    vector<pair<T, int>> ret;\n \
    \   for (T i = 2; i * i <= n; i++) {\n        int cnt = 0;\n        while (n %\
    \ i == 0) {\n            n /= i;\n            cnt++;\n        }\n        if (cnt)\
    \ ret.emplace_back(i, cnt);\n    }\n    if (n > 1) ret.emplace_back(n, 1);\n \
    \   return ret;\n}\n#line 3 \"src/numbers/gcd.hpp\"\n\n// \u975E\u518D\u5E30\u7248\
    \u4F5C\u3063\u3066\u307F\u305F\u3051\u3069\u3001\u901F\u5EA6\u3042\u3093\u307E\
    \u5909\u308F\u3089\u306A\u305D\u3046\u2026\u3002\ntemplate<typename T>\nT gcd(T\
    \ a, T b) {\n    while (b) {\n        T t = a % b;\n        a = b;\n        b\
    \ = t;\n    }\n    return a;\n}\n\n// template<typename T>\n// T gcd(T a, T b)\
    \ { return __gcd(a, b); }\n\ntemplate<typename T>\nT gcd(const vector<T> &A) {\n\
    \    T res = 0;\n    for (auto a : A) res = gcd(res, a);\n    return res;\n}\n\
    #line 4 \"src/numbers/lcm.hpp\"\n\n// \u9664\u7B97\u3092\u524D\u306B\u51FA\u3057\
    \u3066\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3092\u9632\u3050\ntemplate<typename\
    \ T>\nT lcm(T x, T y) {\n    return x / gcd(x, y) * y;\n}\n\ntemplate<typename\
    \ T>\nT lcm(const vector<T> &A) {\n    T res = 1;\n    for (auto a : A) res =\
    \ lcm(res, a);\n    return res;\n}\n#line 67 \"src/template.hpp\"\n\n// from datastructure\n\
    #line 3 \"src/datastructure/Accumulate.hpp\"\n\n// \u7D2F\u7A4D\u548C\ntemplate<typename\
    \ T>\nstruct Accumulate {\n    vector<T> dat;\n    int N;\n    bool built = false;\n\
    \n    Accumulate(int N) : N(N) {\n        dat.resize(N);\n    }\n\n    Accumulate(const\
    \ vector<T> &A) : N(A.size()), dat(A) {\n        build();\n    }\n\n    void set(int\
    \ i, T a) {\n        dat[i] = a;\n    }\n\n    void add(int i, T a) {\n      \
    \  dat[i] += a;\n    }\n\n    void build() {\n        rep(i, N - 1) {\n      \
    \      dat[i + 1] += dat[i];\n        }\n        dat.insert(dat.begin(), 0);\n\
    \        built = true;\n    }\n\n    virtual T query(int l, int r) {\n       \
    \ assert(built);\n        assert(0 <= l and l <= N and 0 <= r and r <= N);\n \
    \       return dat[r] - dat[l];\n    }\n\n    T get(int i) {\n        return query(i,\
    \ i + 1);\n    }\n\n    T operator[](int i) {\n        return query(i, i + 1);\n\
    \    }\n\n    // \u533A\u9593[l, r]\u3092\u5DE6\u304B\u3089\u53F3\u306B\u5411\u304B\
    \u3063\u3066x\u756A\u76EE\u306E\u5024\u304C\u3042\u308B\u4F4D\u7F6E\n    ll bisearch_fore(int\
    \ l, int r, ll x) {\n        if (l > r) return -1;\n        ll l_sm = query(0,\
    \ l);\n        int ok = r + 1;\n        int ng = l - 1;\n        while (ng + 1\
    \ < ok) {\n            int mid = (ok + ng) / 2;\n            if (query(0, mid\
    \ + 1) - l_sm >= x) {\n                ok = mid;\n            } else {\n     \
    \           ng = mid;\n            }\n        }\n        if (ok != r + 1) {\n\
    \            return ok;\n        } else {\n            return -1;\n        }\n\
    \    }\n\n    // \u533A\u9593[l, r]\u3092\u53F3\u304B\u3089\u5DE6\u306B\u5411\u304B\
    \u3063\u3066x\u756A\u76EE\u306E\u5024\u304C\u3042\u308B\u4F4D\u7F6E\n    ll bisearch_back(int\
    \ l, int r, ll x) {\n        if (l > r) return -1;\n        ll r_sm = query(0,\
    \ r + 1);\n        int ok = l - 1;\n        int ng = r + 1;\n        while (ok\
    \ + 1 < ng) {\n            int mid = (ok + ng) / 2;\n            if (r_sm - query(0,\
    \ mid) >= x) {\n                ok = mid;\n            } else {\n            \
    \    ng = mid;\n            }\n        }\n        if (ok != l - 1) {\n       \
    \     return ok;\n        } else {\n            return -1;\n        }\n    }\n\
    };\n#line 3 \"src/datastructure/BIT.hpp\"\n\n// Binary Indexed Tree\ntemplate<typename\
    \ T>\nclass BIT {\nprotected:\n    int n;\n    vector<T> dat;\n\npublic:\n   \
    \ BIT() = default;\n\n    explicit BIT(int n) : n(n) {\n        dat.assign(n +\
    \ 1, T());\n    }\n\n    explicit BIT(const vector<T> &v) : BIT((int)v.size())\
    \ {\n        build(v);\n    }\n\n    virtual void build(const vector<T> &v) {\n\
    \        assert(n == (int)v.size());\n        for (int i = 1; i <= n; i++) {\n\
    \            dat[i] = v[i - 1];\n        }\n        for (int i = 1; i <= n; i++)\
    \ {\n            int j = i + (i & -i);\n            if (j <= n) dat[j] += dat[i];\n\
    \        }\n    }\n\n    // [0, r)\u3092\u5408\u8A08\u3059\u308B\n    virtual\
    \ T sum(int r) {\n        T s = T();\n        for (; r > 0; r -= r & -r) {\n \
    \           s += dat[r];\n        }\n        return s;\n    }\n\n    virtual void\
    \ add(int k, const T &x) {\n        for (++k; k <= n; k += k & -k) {\n       \
    \     dat[k] += x;\n        }\n    }\n\n    // \u533A\u9593\u548C\u306E\u53D6\u5F97\
    \ [l, r)\n    T query(int l, int r) {\n        if (l >= r) return T();\n     \
    \   return sum(r) - sum(l);\n    }\n\n    virtual T get(int i) {\n        // return\
    \ query(i, i + 1);\n        // BIT\u306E\u9AD8\u901F\u306A1\u70B9\u53D6\u5F97\n\
    \        // see: https://twitter.com/KakurenboUni/status/1643832177690550273\n\
    \        T s = this->dat[i + 1];\n        if (i & 1) {\n            int j = i;\n\
    \            i++;\n            i -= i & -i;\n            for (; j > i; j -= j\
    \ & -j) {\n                s -= this->dat[j];\n            }\n        }\n    \
    \    return s;\n    }\n\n    void update(int i, T x) {\n        add(i, x - this->get(i));\n\
    \    }\n\n    T operator[](int i) {\n        return this->get(i);\n    }\n\n \
    \   int size() {\n        return n;\n    }\n\n    // log2\u3064\u306E\u65E7\u4ED5\
    \u69D8\u3002\u65B0\u4ED5\u69D8\u3067\u3042\u308B\u7A0B\u5EA6\u78BA\u8A8D\u304C\
    \u53D6\u308C\u305F\u3089\u524A\u9664\u3002\n    // ll bisearch_fore(int l, int\
    \ r, ll x) {\n    //     if (l > r) return -1;\n    //     ll l_sm = sum(l);\n\
    \    //     int ok = r + 1;\n    //     int ng = l - 1;\n    //     while (ng+1\
    \ < ok) {\n    //         int mid = (ok+ng) / 2;\n    //         if (sum(mid+1)\
    \ - l_sm >= x) {\n    //             ok = mid;\n    //         } else {\n    //\
    \             ng = mid;\n    //         }\n    //     }\n    //     if (ok !=\
    \ r+1) {\n    //         return ok;\n    //     } else {\n    //         return\
    \ -1;\n    //     }\n    // }\n    // ll bisearch_back(int l, int r, ll x) {\n\
    \    //     if (l > r) return -1;\n    //     ll r_sm = sum(r+1);\n    //    \
    \ int ok = l - 1;\n    //     int ng = r + 1;\n    //     while (ok+1 < ng) {\n\
    \    //         int mid = (ok+ng) / 2;\n    //         if (r_sm - sum(mid) >=\
    \ x) {\n    //             ok = mid;\n    //         } else {\n    //        \
    \     ng = mid;\n    //         }\n    //     }\n    //     if (ok != l-1) {\n\
    \    //         return ok;\n    //     } else {\n    //         return -1;\n \
    \   //     }\n    // }\n\n    // \u533A\u9593[l, r]\u3092\u5DE6\u304B\u3089\u53F3\
    \u306B\u5411\u304B\u3063\u3066x\u756A\u76EE\u306E\u5024\u304C\u3042\u308B\u4F4D\
    \u7F6E(log1\u3064\u7248)\n    int bisearch_fore(int l, int r, T x) {\n       \
    \ if (l > r) return -1;\n        assert(l >= 0 and r < n);\n        x += query(0,\
    \ l);\n        T k = lower_bound(x);\n        assert(l <= k);\n        if (k >=\
    \ n) {\n            return -1;\n        } else {\n            return k;\n    \
    \    }\n    }\n\n    // \u533A\u9593[l, r]\u3092\u53F3\u304B\u3089\u5DE6\u306B\
    \u5411\u304B\u3063\u3066x\u756A\u76EE\u306E\u5024\u304C\u3042\u308B\u4F4D\u7F6E\
    (log1\u3064\u7248)\n    int bisearch_back(int l, int r, T x) {\n        if (l\
    \ > r) return -1;\n        assert(l >= 0 and r < n);\n        T total = query(0,\
    \ r + 1);\n        if (total - x < 0) {\n            return -1;\n        }\n \
    \       T k = upper_bound(total - x);\n        assert(k <= r);\n        if (k\
    \ < l) {\n            return -1;\n        } else {\n            return k;\n  \
    \      }\n    }\n\n    // \u53C2\u8003\uFF1Ahttps://ei1333.github.io/library/structure/others/binary-indexed-tree.cpp\n\
    \    // \u533A\u9593[0,k]\u306E\u7DCF\u548C\u304Cx\u4EE5\u4E0A\u3068\u306A\u308B\
    \u6700\u5C0F\u306Ek\u3092\u8FD4\u3059\u3002\u6570\u5217\u304C\u5358\u8ABF\u5897\
    \u52A0\u3067\u3042\u308B\u3053\u3068\u3092\u8981\u6C42\u3059\u308B\u3002\n   \
    \ // (log\u304C1\u3064\u306A\u306E\u3067\u3001TL\u53B3\u3057\u3044\u6642\u306F\
    \u3053\u3061\u3089\u3092\u4F7F\u3046\u3002)\n    int lower_bound(T x) const {\n\
    \        int i = 0;\n        for (int k = 1 << (__lg(n) + 1); k > 0; k >>= 1)\
    \ {\n            if (i + k <= n && dat[i + k] < x) {\n                x -= dat[i\
    \ + k];\n                i += k;\n            }\n        }\n        return i;\n\
    \    }\n\n    // \u533A\u9593[0,k]\u306E\u7DCF\u548C\u304Cx\u3092\u4E0A\u56DE\u308B\
    \u6700\u5C0F\u306Ek\u3092\u8FD4\u3059\u3002\u6570\u5217\u304C\u5358\u8ABF\u5897\
    \u52A0\u3067\u3042\u308B\u3053\u3068\u3092\u8981\u6C42\u3059\u308B\u3002\n   \
    \ int upper_bound(T x) const {\n        int i = 0;\n        for (int k = 1 <<\
    \ (__lg(n) + 1); k > 0; k >>= 1) {\n            if (i + k <= n && dat[i + k] <=\
    \ x) {\n                x -= dat[i + k];\n                i += k;\n          \
    \  }\n        }\n        return i;\n    }\n};\n\ntemplate<typename T>\nostream\
    \ &operator<<(ostream &os, BIT<T> &bit) {\n    rep(i, bit.size()) {\n        os\
    \ << bit[i];\n        if (i != bit.size() - 1) {\n            os << ' ';\n   \
    \     }\n    }\n    return os;\n}\n#line 3 \"src/datastructure/SegmentTree.hpp\"\
    \n\ntemplate<typename Monoid, typename F>\nstruct SegmentTree {\n\n    int sz;\n\
    \    vector<Monoid> seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int\
    \ n, const F f, const Monoid &M1) : f(f), M1(M1) {\n        sz = 1;\n        while\
    \ (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    SegmentTree(const\
    \ F f, const Monoid &M1) : f(f), M1(M1) {\n    }\n\n    SegmentTree(const vector<Monoid>\
    \ &A, const F f, const Monoid &M1)\n        : f(f),\n          M1(M1) {\n    \
    \    build(A);\n    }\n\n    void resize(int n) {\n        sz = 1;\n        while\
    \ (sz < n) sz <<= 1;\n        seg.resize(2 * sz, M1);\n    }\n\n    void clear()\
    \ {\n        seg.clear();\n    }\n\n    void set(int k, const Monoid &x) {\n \
    \       seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz\
    \ - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k], seg[2 * k + 1]);\n  \
    \      }\n    }\n\n    void build(const vector<Monoid> &A) {\n        int n =\
    \ A.size();\n        resize(n);\n        rep(i, n) set(i, A[i]);\n        build();\n\
    \    }\n\n    void update(int k, const Monoid &x) {\n        k += sz;\n      \
    \  seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k],\
    \ seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n   \
    \     Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b\
    \ >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1)\
    \ R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid\
    \ operator[](const int &k) const {\n        return seg[k + sz];\n    }\n\n   \
    \ Monoid all() {\n        return seg[1];\n    }\n\n    void print(int n) {\n \
    \       for (int i = 0; i < n; i++) {\n            cout << query(i, i + 1);\n\
    \            if (i == n - 1) cout << endl;\n            else cout << ' ';\n  \
    \      }\n    }\n\n    template<typename C>\n    int find_subtree(int a, const\
    \ C &check, Monoid &M, bool type) {\n        while (a < sz) {\n            Monoid\
    \ nxt =\n                type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\
    \            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a =\
    \ 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    // \u7BC4\
    \u56F2[a,N)\u3067check\u306E\u6761\u4EF6\u3092\u6E80\u305F\u3059\u3088\u3046\u306A\
    \u6700\u5C0F\u4F4D\u7F6E\u3092\u8FD4\u3059(\u306A\u3051\u308C\u3070-1)\n    template<typename\
    \ C>\n    int find_first(int a, const C &check) {\n        Monoid L = M1;\n  \
    \      if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1,\
    \ check, L, false);\n            return -1;\n        }\n        int b = sz;\n\
    \        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a\
    \ & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt))\
    \ return find_subtree(a, check, L, false);\n                L = nxt;\n       \
    \         ++a;\n            }\n        }\n        return -1;\n    }\n\n    //\
    \ \u7BC4\u56F2[0,b)\u3067check\u306E\u6761\u4EF6\u3092\u6E80\u305F\u3059\u3088\
    \u3046\u306A\u6700\u5927\u4F4D\u7F6E\u3092\u8FD4\u3059(\u306A\u3051\u308C\u3070\
    -1)\n    template<typename C>\n    int find_last(int b, const C &check) {\n  \
    \      Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1],\
    \ R))) return find_subtree(1, check, R, true);\n            return -1;\n     \
    \   }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n\
    \            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n    \
    \            if (check(nxt)) return find_subtree(b, check, R, true);\n       \
    \         R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\
    template<typename Monoid, typename F>\nSegmentTree<Monoid, F> get_segment_tree(int\
    \ N, const F &f, const Monoid &M1) {\n    return {N, f, M1};\n}\n\ntemplate<typename\
    \ Monoid, typename F>\nSegmentTree<Monoid, F> get_segment_tree(const F &f, const\
    \ Monoid &M1) {\n    return {f, M1};\n}\n\ntemplate<typename Monoid, typename\
    \ F>\nSegmentTree<Monoid, F>\nget_segment_tree(const vector<Monoid> &A, const\
    \ F &f, const Monoid &M1) {\n    return {A, f, M1};\n}\n#line 72 \"src/template.hpp\"\
    \n\n// from string\n#line 3 \"src/string/bin.hpp\"\n\nstring bin(ll x) {\n   \
    \ string res;\n    while (x) {\n        if (x & 1) {\n            res += '1';\n\
    \        } else {\n            res += '0';\n        }\n        x >>= 1;\n    }\n\
    \    reverse(ALL(res));\n    if (res == \"\") res += '0';\n    return res;\n}\n\
    #line 3 \"src/string/zfill.hpp\"\n\nstring zfill(string str, int len) {\n    string\
    \ zeros;\n    int n = str.size();\n    rep(i, len - n) zeros += '0';\n    return\
    \ zeros + str;\n}\n#line 76 \"src/template.hpp\"\n"
  code: '#pragma once

    #include "base.hpp"

    #include "macros.hpp"


    // from common

    #include "common/Compress.hpp"

    #include "common/Counter.hpp"

    #include "common/HashMap.hpp"

    #include "common/RLE.hpp"

    #include "common/bisearch.hpp"

    #include "common/bisect.hpp"

    #include "common/bit_length.hpp"

    #include "common/ceil.hpp"

    #include "common/chmax.hpp"

    #include "common/chmin.hpp"

    #include "common/concat.hpp"

    #include "common/divmod.hpp"

    #include "common/input.hpp"

    #include "common/join.hpp"

    #include "common/listnd.hpp"

    #include "common/max.hpp"

    #include "common/min.hpp"

    #include "common/modulo.hpp"

    #include "common/overflow.hpp"

    #include "common/pair.hpp"

    #include "common/popcount.hpp"

    #include "common/pow.hpp"

    #include "common/print.hpp"

    #include "common/reversed.hpp"

    #include "common/sorted.hpp"

    #include "common/split.hpp"

    #include "common/subarray.hpp"

    #include "common/sum.hpp"

    #include "common/tochar.hpp"

    #include "common/toint.hpp"

    #include "common/vector.hpp"

    #include "common/yesno.hpp"

    #include "common/zip.hpp"


    // from combinatorics

    #include "combinatorics/ModTools.hpp"

    #include "combinatorics/combinations.hpp"

    #include "combinatorics/nC2.hpp"

    #include "combinatorics/permutations.hpp"


    // from graph

    #include "graph/UnionFind.hpp"


    // from grid

    #include "grid/constants/directions.hpp"

    #include "grid/gridtoid.hpp"

    #include "grid/idtogrid.hpp"


    // from mystl

    #include "mystl/Deque.hpp"

    #include "mystl/Multiset.hpp"

    #include "mystl/PriorityQueue.hpp"

    #include "mystl/Set.hpp"

    #include "mystl/Vector.hpp"

    #include "mystl/defaultdict.hpp"


    // from numbers

    #include "numbers/divisors.hpp"

    #include "numbers/factorize.hpp"

    #include "numbers/gcd.hpp"

    #include "numbers/lcm.hpp"


    // from datastructure

    #include "datastructure/Accumulate.hpp"

    #include "datastructure/BIT.hpp"

    #include "datastructure/SegmentTree.hpp"


    // from string

    #include "string/bin.hpp"

    #include "string/zfill.hpp"

    '
  dependsOn:
  - src/base.hpp
  - src/macros.hpp
  - src/common/Compress.hpp
  - src/common/Counter.hpp
  - src/common/HashMap.hpp
  - src/common/HashMapImpl.hpp
  - src/common/RLE.hpp
  - src/common/bisearch.hpp
  - src/common/bisect.hpp
  - src/common/bit_length.hpp
  - src/common/ceil.hpp
  - src/common/chmax.hpp
  - src/common/chmin.hpp
  - src/common/concat.hpp
  - src/common/divmod.hpp
  - src/common/input.hpp
  - src/common/join.hpp
  - src/common/to_string.hpp
  - src/common/listnd.hpp
  - src/common/max.hpp
  - src/common/min.hpp
  - src/common/modulo.hpp
  - src/common/overflow.hpp
  - src/common/pair.hpp
  - src/common/popcount.hpp
  - src/common/pow.hpp
  - src/common/print.hpp
  - src/common/reversed.hpp
  - src/common/sorted.hpp
  - src/common/split.hpp
  - src/common/toint.hpp
  - src/common/subarray.hpp
  - src/common/sum.hpp
  - src/common/tochar.hpp
  - src/common/vector.hpp
  - src/common/yesno.hpp
  - src/common/zip.hpp
  - src/combinatorics/ModTools.hpp
  - src/combinatorics/combinations.hpp
  - src/combinatorics/nC2.hpp
  - src/combinatorics/permutations.hpp
  - src/graph/UnionFind.hpp
  - src/grid/constants/directions.hpp
  - src/grid/constants/dir4.hpp
  - src/grid/gridtoid.hpp
  - src/grid/idtogrid.hpp
  - src/mystl/Deque.hpp
  - src/mystl/Multiset.hpp
  - src/mystl/PriorityQueue.hpp
  - src/mystl/Set.hpp
  - src/mystl/Vector.hpp
  - src/mystl/defaultdict.hpp
  - src/numbers/divisors.hpp
  - src/numbers/factorize.hpp
  - src/numbers/gcd.hpp
  - src/numbers/lcm.hpp
  - src/datastructure/Accumulate.hpp
  - src/datastructure/BIT.hpp
  - src/datastructure/SegmentTree.hpp
  - src/string/bin.hpp
  - src/string/zfill.hpp
  isVerificationFile: false
  path: src/template.hpp
  requiredBy: []
  timestamp: '2023-12-06 04:35:49+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: src/template.hpp
layout: document
redirect_from:
- /library/src/template.hpp
- /library/src/template.hpp.html
title: src/template.hpp
---
